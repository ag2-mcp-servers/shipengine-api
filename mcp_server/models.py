# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T09:12:22+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import List, Optional, Union
from uuid import UUID

from pydantic import (
    BaseModel,
    ConfigDict,
    EmailStr,
    Field,
    PositiveFloat,
    RootModel,
    confloat,
    conint,
    constr,
)


class AddressResidentialIndicator(Enum):
    unknown = 'unknown'
    yes = 'yes'
    no = 'no'


class AddressValidationCode(Enum):
    a1000 = 'a1000'
    a1001 = 'a1001'
    a1002 = 'a1002'
    a1003 = 'a1003'
    a1004 = 'a1004'
    a1005 = 'a1005'
    a1006 = 'a1006'
    a1007 = 'a1007'
    a1008 = 'a1008'
    r1000 = 'r1000'
    r1001 = 'r1001'
    r1002 = 'r1002'
    r1003 = 'r1003'


class AddressValidationDetailCode(Enum):
    unsupported_country = 'unsupported_country'
    non_supported_country = 'non_supported_country'
    minimum_postal_code_verification_failed = 'minimum_postal_code_verification_failed'
    street_does_not_match_unique_street_name = (
        'street_does_not_match_unique_street_name'
    )
    multiple_directionals = 'multiple_directionals'
    multiple_matches = 'multiple_matches'
    suite_not_valid = 'suite_not_valid'
    suite_missing = 'suite_missing'
    incompatible_paired_labels = 'incompatible_paired_labels'
    invalid_house_number = 'invalid_house_number'
    missing_house_number = 'missing_house_number'
    invalid_box_number = 'invalid_box_number'
    invalid_charge_event = 'invalid_charge_event'
    missing_box_number = 'missing_box_number'
    missing_cmra_or_private_mail_box_number = 'missing_cmra_or_private_mail_box_number'
    suite_has_no_secondaries = 'suite_has_no_secondaries'
    postal_code_changed_or_added = 'postal_code_changed_or_added'
    state_province_changed_or_added = 'state_province_changed_or_added'
    city_locality_changed_or_added = 'city_locality_changed_or_added'
    urbanization_changed = 'urbanization_changed'
    street_name_spelling_changed_or_added = 'street_name_spelling_changed_or_added'
    street_name_type_changed_or_added = 'street_name_type_changed_or_added'
    street_direction_changed_or_added = 'street_direction_changed_or_added'
    suite_type_changed_or_added = 'suite_type_changed_or_added'
    suite_unit_number_changed_or_added = 'suite_unit_number_changed_or_added'
    double_dependent_locality_changed_or_added = (
        'double_dependent_locality_changed_or_added'
    )
    subadministrative_area_changed_or_added = 'subadministrative_area_changed_or_added'
    subnational_area_changed_or_added = 'subnational_area_changed_or_added'
    po_box_changed_or_added = 'po_box_changed_or_added'
    premise_type_changed_or_added = 'premise_type_changed_or_added'
    house_number_changed = 'house_number_changed'
    organization_changed_or_added = 'organization_changed_or_added'
    partially_verified_to_state_level = 'partially_verified_to_state_level'
    partially_verified_to_city_level = 'partially_verified_to_city_level'
    partially_verified_to_street_level = 'partially_verified_to_street_level'
    partially_verified_to_premise_level = 'partially_verified_to_premise_level'
    verified_to_state_level = 'verified_to_state_level'
    verified_to_city_level = 'verified_to_city_level'
    verified_to_street_level = 'verified_to_street_level'
    verified_to_premise_level = 'verified_to_premise_level'
    verified_to_suite_level = 'verified_to_suite_level'
    coded_to_street_lavel = 'coded_to_street_lavel'
    coded_to_neighborhood_level = 'coded_to_neighborhood_level'
    coded_to_community_level = 'coded_to_community_level'
    coded_to_state_level = 'coded_to_state_level'
    coded_to_rooftop_level = 'coded_to_rooftop_level'
    coded_to_rooftop_interpolation_level = 'coded_to_rooftop_interpolation_level'
    name_max_length_exceeded = 'name_max_length_exceeded'
    phone_max_length_exceeded = 'phone_max_length_exceeded'
    company_name_max_length_exceeded = 'company_name_max_length_exceeded'
    line1_min_max_length = 'line1_min_max_length'
    line2_max_length_exceeded = 'line2_max_length_exceeded'
    line3_max_length_exceeded = 'line3_max_length_exceeded'
    city_locality_max_length_exceeded = 'city_locality_max_length_exceeded'
    state_province_max_length_exceeded = 'state_province_max_length_exceeded'
    invalid_postal_code = 'invalid_postal_code'
    country_invalid_length = 'country_invalid_length'
    address_not_found = 'address_not_found'


class AddressValidationMessageType(Enum):
    error = 'error'
    warning = 'warning'
    info = 'info'


class AddressValidationStatus(Enum):
    unverified = 'unverified'
    verified = 'verified'
    warning = 'warning'
    error = 'error'


class FedexFreight(BaseModel):
    booking_confirmation: Optional[str] = None
    shipper_load_and_count: Optional[str] = None


class AlternativeIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Optional[constr(min_length=1)] = Field(
        None,
        description='The type of alternative_identifier that corresponds to the value.\n',
        examples=['last_mile_tracking_number'],
    )
    value: Optional[constr(min_length=1)] = Field(
        None,
        description='The value of the alternative_identifier.\n',
        examples=['12345678912345678912'],
    )


class AncillaryServiceEndorsement(Enum):
    none = 'none'
    return_service_requested = 'return_service_requested'
    forwarding_service_requested = 'forwarding_service_requested'
    address_service_requested = 'address_service_requested'
    change_service_requested = 'change_service_requested'
    leave_if_no_response = 'leave_if_no_response'


class BatchStatus(Enum):
    open = 'open'
    queued = 'queued'
    processing = 'processing'
    completed = 'completed'
    completed_with_errors = 'completed_with_errors'
    archived = 'archived'
    notifying = 'notifying'
    invalid = 'invalid'


class BatchesSortBy(Enum):
    ship_date = 'ship_date'
    processed_at = 'processed_at'
    created_at = 'created_at'


class BillToParty(Enum):
    recipient = 'recipient'
    third_party = 'third_party'


class CarrierAdvancedOption(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    default_value: Optional[constr(min_length=1)] = Field(
        None, description='Default value of option', examples=[False]
    )
    description: Optional[constr(min_length=0)] = Field(
        None, description='Description of option'
    )
    name: Optional[constr(min_length=1)] = Field(
        None, description='Name of advanced option', examples=['contains_alcohol']
    )


class CarrierCode(RootModel[constr(pattern=r'^[a-z0-9]+(_[a-z0-9]+)*$')]):
    root: constr(pattern=r'^[a-z0-9]+(_[a-z0-9]+)*$') = Field(
        ...,
        description='A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as `fedex`, `dhl_express`, `stamps_com`, etc.\n',
        examples=['dhl_express'],
        title='carrier_code',
    )


class CarrierName(Enum):
    access_worldwide = 'access_worldwide'
    amazon_buy_shipping = 'amazon_buy_shipping'
    amazon_shipping_uk = 'amazon_shipping_uk'
    apc = 'apc'
    asendia = 'asendia'
    australia_post = 'australia_post'
    canada_post = 'canada_post'
    dhl_ecommerce = 'dhl_ecommerce'
    dhl_express = 'dhl_express'
    dhl_express_au = 'dhl_express_au'
    dhl_express_ca = 'dhl_express_ca'
    dhl_express_uk = 'dhl_express_uk'
    dpd = 'dpd'
    endicia = 'endicia'
    fedex = 'fedex'
    fedex_uk = 'fedex_uk'
    firstmile = 'firstmile'
    imex = 'imex'
    newgistics = 'newgistics'
    ontrac = 'ontrac'
    purolator_canada = 'purolator_canada'
    royal_mail = 'royal_mail'
    rr_donnelley = 'rr_donnelley'
    seko = 'seko'
    sendle = 'sendle'
    stamps_com = 'stamps_com'
    ups = 'ups'


class CarrierNameWithSettings(Enum):
    dhl_express = 'dhl_express'
    fedex = 'fedex'
    newgistics = 'newgistics'
    ups = 'ups'


class CollectOnDeliveryPaymentType(Enum):
    any = 'any'
    cash = 'cash'
    cash_equivalent = 'cash_equivalent'
    none = 'none'


class ConnectAccessWorldwideRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    nickname: constr(min_length=1) = Field(
        ...,
        description='The nickname associated with the carrier connection',
        examples=['Stamps.com'],
    )
    password: constr(min_length=1) = Field(..., description='Access Worldwide Password')
    username: constr(min_length=1) = Field(..., description='Access Worldwide Username')


class ConnectAmazonShippingUk(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    auth_code: constr(min_length=1) = Field(
        ..., description='Amazon UK Shipping auth code.'
    )
    nickname: constr(min_length=1) = Field(
        ...,
        description='The nickname associated with the carrier connection',
        examples=['Stamps.com'],
    )


class ConnectApcRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    nickname: constr(min_length=1) = Field(
        ...,
        description='The nickname for the APC account',
        examples=['APC carrier account'],
    )
    password: constr(min_length=1) = Field(
        ..., description='The password for the APC account', examples=[12345]
    )
    username: constr(min_length=1) = Field(
        ..., description='The username for the APC account', examples=['john_doe']
    )


class ConnectAsendiaRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account_number: constr(min_length=1) = Field(
        ..., description='Asendia account number'
    )
    ftp_password: constr(min_length=1) = Field(..., description='FTP password')
    ftp_username: constr(min_length=1) = Field(..., description='FTP username')
    nickname: constr(min_length=1) = Field(
        ...,
        description='The nickname of the Asendia account',
        examples=['Asendia account'],
    )


class ConnectAustraliaPostRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account_number: constr(min_length=1) = Field(..., description='Account number')
    api_key: constr(min_length=1) = Field(..., description='API key')
    api_secret: constr(min_length=1) = Field(..., description='API secret')
    nickname: constr(min_length=1) = Field(..., description='Nickname')


class ConnectCanadaPostRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account_number: constr(min_length=1) = Field(
        ..., description='Canada Post Account Number'
    )
    api_key: constr(min_length=1) = Field(
        ..., description='Canada Post Account API Key'
    )
    api_secret: constr(min_length=1) = Field(
        ..., description='Canada Post Account API Secret'
    )
    contract_id: constr(min_length=1) = Field(
        ..., description='Canada Post Account Contract ID'
    )
    nickname: constr(min_length=1) = Field(..., description='Nickname')


class ConnectDhlEcommerceRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account_number: Optional[constr(min_length=1)] = Field(
        None, description='Account number'
    )
    ancillary_endorsement: Optional[AncillaryServiceEndorsement] = None
    api_key: Optional[constr(min_length=1)] = Field(
        None,
        description='The DHL E-Commerce API key. This field is optional, but if not set you will not be able to get rates for this account.\n',
    )
    api_secret: Optional[constr(min_length=1)] = Field(
        None,
        description='The DHL E-Commerce API secret. This field is optional, but if not set you will not be able to get rates for this account.\n',
    )
    client_id: constr(min_length=1) = Field(..., description='The client id')
    distribution_center: constr(min_length=1) = Field(
        ..., description='The distribution center'
    )
    ftp_password: Optional[constr(min_length=1)] = Field(
        None, description='FTP password'
    )
    ftp_username: Optional[constr(min_length=1)] = Field(
        None, description='FTP username'
    )
    nickname: constr(min_length=1) = Field(
        ..., description='A nickname to help you identify this account'
    )
    password: constr(min_length=1) = Field(..., description='The account password')
    pickup_number: constr(min_length=1) = Field(..., description='The pickup number')
    registration_id: Optional[str] = None
    software_name: Optional[str] = None
    sold_to: Optional[str] = Field(None, description='Sold To field')
    username: constr(min_length=1) = Field(..., description='The account username')


class ConnectDhlExpressAuRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account_number: constr(min_length=1) = Field(..., description='Account number')
    nickname: constr(min_length=1) = Field(..., description='Nickname')


class ConnectDhlExpressCaRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account_number: constr(min_length=1) = Field(..., description='Account number')
    nickname: constr(min_length=1) = Field(..., description='Nickname')


class ConnectDpdRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account_number: constr(min_length=1) = Field(..., description='Account number')
    nickname: constr(min_length=1) = Field(..., description='Nickname')
    password: constr(min_length=1) = Field(..., description='Password')


class ConnectEndiciaRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account: constr(min_length=1) = Field(..., description='Account')
    nickname: constr(min_length=1) = Field(..., description='Nickname')
    passphrase: constr(min_length=1) = Field(..., description='Passphrase')


class ConnectImexRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    nickname: constr(min_length=1) = Field(..., description='Nickname')
    password: constr(min_length=1) = Field(..., description='Password')
    username: constr(min_length=1) = Field(..., description='Username')


class ConnectInsurerResponseBody(BaseModel):
    pass


class ConnectNewgisticsRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    induction_site: constr(min_length=1) = Field(..., description='Induction site')
    mailer_id: Optional[conint(ge=0)] = Field(None, description='Mailer id')
    merchant_id: Optional[conint(ge=0)] = Field(None, description='Merchant id')
    nickname: constr(min_length=1) = Field(..., description='Nickname')


class ConnectOntracRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account_number: constr(min_length=1) = Field(..., description='Account number')
    nickname: constr(min_length=1) = Field(..., description='Nickname')
    password: constr(min_length=1) = Field(..., description='Password')


class ConnectPurolatorRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account_number: constr(min_length=1) = Field(..., description='Account number')
    activation_key: constr(min_length=1) = Field(..., description='Activation key')
    nickname: constr(min_length=1) = Field(..., description='Nickname')


class ConnectRrDonnelleyRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    nickname: constr(min_length=1) = Field(..., description='Nickname')
    password: constr(min_length=1) = Field(..., description='Password')
    username: constr(min_length=1) = Field(..., description='Username')


class ConnectSekoRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    access_key: constr(min_length=1) = Field(..., description='Seko Account Access Key')
    nickname: constr(min_length=1) = Field(..., description='Nickname')


class ConnectStampsRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    nickname: constr(min_length=1) = Field(..., description='Nickname')
    password: constr(min_length=1) = Field(..., description='Password')
    username: constr(min_length=1) = Field(..., description='Username')


class CountryCode(RootModel[constr(min_length=2, max_length=2)]):
    root: constr(min_length=2, max_length=2) = Field(
        ...,
        description='A two-letter [ISO 3166-1 country code](https://en.wikipedia.org/wiki/ISO_3166-1)\n',
        examples=['CA'],
        title='country_code',
    )


class Currency(RootModel[str]):
    root: str = Field(
        ...,
        description='The currencies that are supported by ShipEngine are the ones that specified by ISO 4217: https://www.iso.org/iso-4217-currency-codes.html\n',
        title='currency',
    )


class Date(RootModel[datetime]):
    root: datetime = Field(
        ...,
        description='An [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string that represents a date, but not a specific time.  The value _may_ contain a time component, but it will be set to `00:00:00` UTC by ShipEngine.\n',
        examples=['2018-09-23T00:00:00.000Z'],
        title='date',
    )


class DateTime(RootModel[datetime]):
    root: datetime = Field(
        ...,
        description='An [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string that represents a date and time.\n',
        examples=['2018-09-23T15:00:00.000Z'],
        title='date_time',
    )


class DeliveryConfirmation(Enum):
    none = 'none'
    delivery = 'delivery'
    signature = 'signature'
    adult_signature = 'adult_signature'
    direct_signature = 'direct_signature'
    delivery_mailed = 'delivery_mailed'
    verbal_confirmation = 'verbal_confirmation'


class DhlExpressAccountSettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    is_primary_account: Optional[bool] = Field(
        None, description='Indicates if this is primary account'
    )
    nickname: Optional[constr(min_length=1)] = Field(
        None, description='Account nickname'
    )
    should_hide_account_number_on_archive_doc: Optional[bool] = Field(
        None,
        description='Indicates if the account number should be hidden on the archive documentation',
    )


class DhlExpressSettingsResponseBody(DhlExpressAccountSettings):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class DimensionUnit(Enum):
    inch = 'inch'
    centimeter = 'centimeter'


class Dimensions(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    height: confloat(ge=0.0) = Field(
        ..., description='The length of the package, in the specified unit'
    )
    length: confloat(ge=0.0) = Field(
        ..., description='The length of the package, in the specified unit'
    )
    unit: DimensionUnit
    width: confloat(ge=0.0) = Field(
        ..., description='The width of the package, in the specified unit'
    )


class DisconnectInsurerResponseBody(BaseModel):
    pass


class DisplayScheme(Enum):
    label = 'label'
    qr_code = 'qr_code'
    label_and_qr_code = 'label_and_qr_code'


class DownloadFilePdfResponseBody(RootModel[bytes]):
    root: bytes = Field(..., title='download_file_pdf_response_body')


class DownloadFilePngResponseBody(RootModel[bytes]):
    root: bytes = Field(..., title='download_file_png_response_body')


class DownloadFileZplResponseBody(RootModel[bytes]):
    root: bytes = Field(..., title='download_file_zpl_response_body')


class Email(RootModel[EmailStr]):
    root: EmailStr = Field(
        ...,
        description='An email address.',
        examples=['john.doe@example.com'],
        title='email',
    )


class EmptyResponseBody(RootModel[constr(max_length=0)]):
    root: constr(max_length=0) = Field(..., title='empty_response_body')


class ErrorCode(Enum):
    auto_fund_not_supported = 'auto_fund_not_supported'
    batch_cannot_be_modified = 'batch_cannot_be_modified'
    carrier_conflict = 'carrier_conflict'
    carrier_disconnected = 'carrier_disconnected'
    carrier_not_connected = 'carrier_not_connected'
    carrier_not_supported = 'carrier_not_supported'
    confirmation_not_supported = 'confirmation_not_supported'
    default_warehouse_cannot_be_deleted = 'default_warehouse_cannot_be_deleted'
    field_conflict = 'field_conflict'
    field_value_required = 'field_value_required'
    forbidden = 'forbidden'
    identifier_conflict = 'identifier_conflict'
    identifiers_must_match = 'identifiers_must_match'
    insufficient_funds = 'insufficient_funds'
    invalid_address = 'invalid_address'
    invalid_billing_plan = 'invalid_billing_plan'
    invalid_field_value = 'invalid_field_value'
    invalid_identifier = 'invalid_identifier'
    invalid_status = 'invalid_status'
    invalid_string_length = 'invalid_string_length'
    label_images_not_supported = 'label_images_not_supported'
    meter_failure = 'meter_failure'
    order_source_not_active = 'order_source_not_active'
    rate_limit_exceeded = 'rate_limit_exceeded'
    refresh_not_supported = 'refresh_not_supported'
    request_body_required = 'request_body_required'
    return_label_not_supported = 'return_label_not_supported'
    settings_not_supported = 'settings_not_supported'
    subscription_inactive = 'subscription_inactive'
    terms_not_accepted = 'terms_not_accepted'
    tracking_not_supported = 'tracking_not_supported'
    trial_expired = 'trial_expired'
    unauthorized = 'unauthorized'
    unknown = 'unknown'
    unspecified = 'unspecified'
    verification_failure = 'verification_failure'
    warehouse_conflict = 'warehouse_conflict'
    webhook_event_type_conflict = 'webhook_event_type_conflict'


class ErrorSource(Enum):
    carrier = 'carrier'
    order_source = 'order_source'
    shipengine = 'shipengine'


class ErrorType(Enum):
    account_status = 'account_status'
    business_rules = 'business_rules'
    validation = 'validation'
    security = 'security'
    system = 'system'
    integrations = 'integrations'


class FedexPickupType(Enum):
    none = 'none'
    regular_pickup = 'regular_pickup'
    request_courier = 'request_courier'
    drop_box = 'drop_box'
    business_service_center = 'business_service_center'
    station = 'station'


class GetCarrierOptionsResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    options: Optional[List[CarrierAdvancedOption]] = Field(
        None, description='AN array of carrier options'
    )


class Feature(Enum):
    drop_off_point = 'drop_off_point'
    pickup_point = 'pickup_point'
    print_services = 'print_services'
    after_hours_locker = 'after_hours_locker'
    after_hours_dropbox = 'after_hours_dropbox'


class FridayItem(BaseModel):
    close: Optional[str] = Field(None, examples=['12:00'])
    open: Optional[str] = Field(None, examples=['09:15'])


class MondayItem(BaseModel):
    close: Optional[str] = Field(None, examples=['12:00'])
    open: Optional[str] = Field(None, examples=['09:15'])


class SaturdayItem(BaseModel):
    close: Optional[str] = Field(None, examples=['12:00'])
    open: Optional[str] = Field(None, examples=['09:15'])


class SundayItem(BaseModel):
    close: Optional[str] = Field(None, examples=['12:00'])
    open: Optional[str] = Field(None, examples=['09:15'])


class ThursdayItem(BaseModel):
    close: Optional[str] = Field(None, examples=['12:00'])
    open: Optional[str] = Field(None, examples=['09:15'])


class TuesdayItem(BaseModel):
    close: Optional[str] = Field(None, examples=['12:00'])
    open: Optional[str] = Field(None, examples=['09:15'])


class WednesdayItem(BaseModel):
    close: Optional[str] = Field(None, examples=['12:00'])
    open: Optional[str] = Field(None, examples=['09:15'])


class HoursOfOperation(BaseModel):
    friday: Optional[List[FridayItem]] = None
    monday: Optional[List[MondayItem]] = None
    saturday: Optional[List[SaturdayItem]] = None
    sunday: Optional[List[SundayItem]] = None
    thursday: Optional[List[ThursdayItem]] = None
    tuesday: Optional[List[TuesdayItem]] = None
    wednesday: Optional[List[WednesdayItem]] = None


class ServicePoint(BaseModel):
    address_line1: Optional[str] = Field(None, examples=['PLACE DU CANADA'])
    carrier_code: Optional[str] = Field(None, examples=['chronopost'])
    city_locality: Optional[str] = Field(None, examples=['TRUN'])
    company_name: Optional[str] = Field(None, examples=['My fancy company name'])
    country_code: Optional[str] = Field(None, examples=['FR'])
    features: Optional[List[Feature]] = None
    hours_of_operation: Optional[HoursOfOperation] = None
    lat: Optional[float] = Field(None, examples=[48.842608])
    long: Optional[float] = Field(None, examples=[0.032875])
    phone_number: Optional[str] = Field(None, examples=['555-555-5555'])
    postal_code: Optional[str] = Field(None, examples=['61160'])
    service_codes: Optional[List[str]] = None
    service_point_id: Optional[str] = Field(None, examples=['614940'])
    state_province: Optional[str] = Field(None, examples=['TRUN'])


class GetServicePointByIdResponseBody(BaseModel):
    service_point: Optional[ServicePoint] = None


class Address1(BaseModel):
    address_line1: Optional[str] = None
    address_line2: Optional[str] = None
    address_line3: Optional[str] = None
    city_locality: Optional[str] = None
    country_code: str
    postal_code: Optional[str] = None
    state_province: Optional[str] = None


class Provider(BaseModel):
    carrier_id: Optional[str] = Field(
        None,
        description='Uniquely identifies a carrier connection',
        examples=['se-123456'],
    )
    service_code: Optional[List[str]] = None


class GetServicePointsRequestBody(BaseModel):
    address: Optional[Address1] = Field(
        None, description='Structured address to search by.'
    )
    address_query: Optional[str] = Field(
        None,
        description='Unstructured text to search for service points by.',
        examples=['177A Bleecker Street New York'],
    )
    lat: Optional[float] = Field(
        None,
        description='The latitude of the point. Represented as signed degrees. Required if long is provided. http://www.geomidpoint.com/latlon.html',
        examples=[48.874518928233094],
    )
    long: Optional[float] = Field(
        None,
        description='The longitude of the point. Represented as signed degrees. Required if lat is provided. http://www.geomidpoint.com/latlon.html',
        examples=[2.3591775711639404],
    )
    max_results: Optional[int] = Field(
        None,
        description='The maximum number of service points to return',
        examples=[25],
    )
    providers: List[Provider] = Field(
        ..., description='An array of shipping service providers and service codes'
    )
    radius: Optional[int] = Field(
        None, description='Search radius in kilometers', examples=[500]
    )


class IdentifierType(Enum):
    vat = 'vat'
    eori = 'eori'
    ssn = 'ssn'
    ein = 'ein'
    tin = 'tin'
    ioss = 'ioss'
    pan = 'pan'
    voec = 'voec'


class ImageId(RootModel[constr(min_length=4)]):
    root: constr(min_length=4) = Field(
        ...,
        description='Used to identify an image resource.',
        examples=['img_DtBXupDBxREpHnwEXhTfgK'],
        title='image_id',
    )


class InsuranceProvider(Enum):
    none = 'none'
    shipsurance = 'shipsurance'
    carrier = 'carrier'
    third_party = 'third_party'


class LabelChargeEvent(Enum):
    carrier_default = 'carrier_default'
    on_creation = 'on_creation'
    on_carrier_acceptance = 'on_carrier_acceptance'


class LabelDownloadType(Enum):
    url = 'url'
    inline = 'inline'


class LabelFormat(Enum):
    pdf = 'pdf'
    png = 'png'
    zpl = 'zpl'


class LabelLayout(Enum):
    field_4x6 = '4x6'
    letter = 'letter'


class LabelMessages(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    reference1: str = Field(
        ...,
        description='The first line of the custom label message.  Some carriers may prefix this line with something like "REF", "Reference", "Trx Ref No.", etc.\n',
    )
    reference2: str = Field(
        ...,
        description='The second line of the custom label message.  Some carriers may prefix this line with something like "INV", "Reference 2", "Trx Ref No.", etc.\n',
    )
    reference3: str = Field(
        ...,
        description='The third line of the custom label message.  Some carriers may prefix this line with something like "PO", "Reference 3", etc.\n',
    )


class LabelStatus(Enum):
    processing = 'processing'
    completed = 'completed'
    error = 'error'
    voided = 'voided'


class HoursOfOperation1(BaseModel):
    friday: Optional[List[FridayItem]] = None
    monday: Optional[List[MondayItem]] = None
    saturday: Optional[List[SaturdayItem]] = None
    sunday: Optional[List[SundayItem]] = None
    thursday: Optional[List[ThursdayItem]] = None
    tuesday: Optional[List[TuesdayItem]] = None
    wednesday: Optional[List[WednesdayItem]] = None


class ServicePoint1(BaseModel):
    address_line1: Optional[str] = Field(None, examples=['PLACE DU CANADA'])
    carrier_code: Optional[str] = Field(None, examples=['chronopost'])
    city_locality: Optional[str] = Field(None, examples=['TRUN'])
    company_name: Optional[str] = Field(None, examples=['My fancy company name'])
    country_code: Optional[str] = Field(None, examples=['FR'])
    distance_in_meters: Optional[float] = Field(None, examples=[728.9959308847579])
    features: Optional[List[Feature]] = None
    hours_of_operation: Optional[HoursOfOperation1] = None
    lat: Optional[float] = Field(None, examples=[48.842608])
    long: Optional[float] = Field(None, examples=[0.032875])
    phone_number: Optional[str] = Field(None, examples=['555-555-5555'])
    postal_code: Optional[str] = Field(None, examples=['61160'])
    service_codes: Optional[List[str]] = None
    service_point_id: Optional[str] = Field(None, examples=['614940'])
    state_province: Optional[str] = Field(None, examples=['TRUN'])


class ManifestRequestStatus(Enum):
    in_progress = 'in_progress'
    completed = 'completed'


class MonetaryValue(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    amount: confloat(ge=0.0) = Field(
        ..., description='The monetary amount, in the specified currency.'
    )
    currency: Currency


class NonDelivery(Enum):
    return_to_sender = 'return_to_sender'
    treat_as_abandoned = 'treat_as_abandoned'


class NormalizedEntity(BaseModel):
    pass
    model_config = ConfigDict(
        extra='allow',
    )


class OrderSourceName(Enum):
    amazon_ca = 'amazon_ca'
    amazon_us = 'amazon_us'
    brightpearl = 'brightpearl'
    channel_advisor = 'channel_advisor'
    cratejoy = 'cratejoy'
    ebay = 'ebay'
    etsy = 'etsy'
    jane = 'jane'
    groupon_goods = 'groupon_goods'
    magento = 'magento'
    paypal = 'paypal'
    seller_active = 'seller_active'
    shopify = 'shopify'
    stitch_labs = 'stitch_labs'
    squarespace = 'squarespace'
    three_dcart = 'three_dcart'
    tophatter = 'tophatter'
    walmart = 'walmart'
    woo_commerce = 'woo_commerce'
    volusion = 'volusion'


class OriginType(Enum):
    pickup = 'pickup'
    drop_off = 'drop_off'


class PackageCode(RootModel[constr(pattern=r'^[a-z0-9]+(_[a-z0-9]+)*$')]):
    root: constr(pattern=r'^[a-z0-9]+(_[a-z0-9]+)*$') = Field(
        ...,
        description='A [package type](https://www.shipengine.com/docs/reference/list-carrier-packages/), such as `thick_envelope`, `small_flat_rate_box`, `large_package`, etc.  Use the code `package` for custom or unknown package types.\n',
        examples=['small_flat_rate_box'],
        title='package_code',
    )


class PackageContents(Enum):
    merchandise = 'merchandise'
    documents = 'documents'
    gift = 'gift'
    returned_goods = 'returned_goods'
    sample = 'sample'


class PartialShippingAddress(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    instructions: Optional[constr(min_length=1)] = Field(
        None,
        description='Additional text about how to handle the shipment at this address.\n',
    )


class PaymentAmount(BaseModel):
    amount: Optional[confloat(ge=0.0)] = None
    currency: Optional[Currency] = None


class PickupResourceId(RootModel[constr(min_length=4)]):
    root: constr(min_length=4) = Field(
        ...,
        description='Pickup Resource ID',
        examples=['pik_3YcKU5zdtJuCqoeNwyqqbW'],
        title='pickup_resource_id',
    )


class PickupWindow(BaseModel):
    end_at: DateTime
    start_at: DateTime


class PickupWindows(BaseModel):
    end_at: Optional[DateTime] = None
    start_at: Optional[DateTime] = None


class PostalCode(RootModel[constr(min_length=1)]):
    root: constr(min_length=1) = Field(
        ..., description='postal code', examples=['78756-3717'], title='postal_code'
    )


class ProcessBatchRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    display_scheme: Optional[DisplayScheme] = Field(
        'label', description='The display format that the label should be shown in.'
    )
    label_format: Optional[LabelFormat] = 'pdf'
    label_layout: Optional[LabelLayout] = '4x6'
    ship_date: Optional[DateTime] = Field(
        None, description='The Ship date the batch is being processed for'
    )


class ErrorMessage(RootModel[constr(min_length=0)]):
    root: constr(min_length=0) = Field(..., description='error message')


class WarningMessage(RootModel[constr(min_length=0)]):
    root: constr(min_length=0) = Field(..., description='warning message')


class RateResponseStatus(Enum):
    working = 'working'
    completed = 'completed'
    partial = 'partial'
    error = 'error'


class RateType(Enum):
    check = 'check'
    shipment = 'shipment'


class RecognizedEntity(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    end_index: conint(ge=0) = Field(
        ...,
        description='The index of the last character of this entity within the original text',
    )
    result: Optional[NormalizedEntity] = None
    score: confloat(ge=0.0, le=1.0) = Field(
        ...,
        description='A confidence score between zero and one that indicates how certain the API is that it correctly recognized this entity\n',
    )
    start_index: conint(ge=0) = Field(
        ...,
        description='The index of the first character of this entity within the original text',
    )
    text: constr(min_length=1) = Field(
        ...,
        description='The substring from the original text that was recognized as this entity',
    )
    type: constr(min_length=1) = Field(
        ...,
        description='The Entity type (e.g. "weight", "person", "address_line1", etc.)',
    )


class Redirect(Enum):
    shipengine_dashboard = 'shipengine-dashboard'


class ResponseMessage(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    code: AddressValidationCode
    detail_code: AddressValidationDetailCode
    message: constr(min_length=1) = Field(
        ...,
        description='Message explaining the address validation error',
        examples=['Invalid Postal Code'],
    )
    type: AddressValidationMessageType


class SeId(
    RootModel[constr(pattern=r'^se(-[a-z0-9]+)+$', min_length=1, max_length=25)]
):
    root: constr(pattern=r'^se(-[a-z0-9]+)+$', min_length=1, max_length=25) = Field(
        ...,
        description='A string that uniquely identifies a ShipEngine resource, such as a carrier, label, shipment, etc.',
        examples=['se-28529731'],
        title='se_id',
    )


class Service(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    carrier_code: Optional[SeId] = None
    carrier_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the carrier'
    )
    domestic: Optional[bool] = Field(None, description='Supports domestic shipping')
    international: Optional[bool] = Field(
        None, description='Supports international shipping.'
    )
    is_multi_package_supported: Optional[bool] = Field(
        None, description='Carrier supports multiple packages per shipment'
    )
    name: Optional[constr(min_length=1)] = Field(
        None,
        description='User friendly service name',
        examples=['USPS First Class Mail'],
    )
    service_code: Optional[constr(min_length=1)] = Field(
        None, description='service code', examples=['usps_media_mail']
    )


class ServiceCode(RootModel[constr(pattern=r'^[a-z0-9]+(_[a-z0-9-]+)* ?$')]):
    root: constr(pattern=r'^[a-z0-9]+(_[a-z0-9-]+)* ?$') = Field(
        ...,
        description='A [carrier service](https://www.shipengine.com/docs/shipping/use-a-carrier-service/), such as `fedex_ground`, `usps_first_class_mail`, `flat_rate_envelope`, etc.\n',
        examples=['usps_first_class_mail'],
        title='service_code',
    )


class ShipmentIdRequest(BaseModel):
    shipment_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the shipment'
    )


class ShipmentItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    asin: Optional[constr(min_length=10, max_length=10)] = Field(
        None,
        description='Amazon Standard Identification Number',
        examples=['B00005N5PF'],
    )
    external_order_id: Optional[str] = Field(None, description='external order id')
    external_order_item_id: Optional[str] = Field(
        None, description='external order item id'
    )
    name: Optional[constr(min_length=0)] = Field(None, description='item name')
    order_source_code: Optional[OrderSourceName] = None
    quantity: Optional[conint(ge=0)] = Field(
        None, description='The quantity of this item included in the shipment'
    )
    sales_order_id: Optional[str] = Field(None, description='sales order id')
    sales_order_item_id: Optional[str] = Field(None, description='sales order item id')
    sku: Optional[str] = Field(None, description='Item Stock Keeping Unit')


class ShipmentStatus(Enum):
    pending = 'pending'
    processing = 'processing'
    label_purchased = 'label_purchased'
    cancelled = 'cancelled'


class ShipmentsSortBy(Enum):
    modified_at = 'modified_at'
    created_at = 'created_at'


class SmartPostHub(Enum):
    none = 'none'
    allentown_pa = 'allentown_pa'
    atlanta_ga = 'atlanta_ga'
    baltimore_md = 'baltimore_md'
    charlotte_nc = 'charlotte_nc'
    chino_ca = 'chino_ca'
    dallas_tx = 'dallas_tx'
    denver_co = 'denver_co'
    detroit_mi = 'detroit_mi'
    edison_nj = 'edison_nj'
    grove_city_oh = 'grove_city_oh'
    groveport_oh = 'groveport_oh'
    houston_tx = 'houston_tx'
    indianapolis_in = 'indianapolis_in'
    kansas_city_ks = 'kansas_city_ks'
    los_angeles_ca = 'los_angeles_ca'
    martinsburg_wv = 'martinsburg_wv'
    memphis_tn = 'memphis_tn'
    minneapolis_mn = 'minneapolis_mn'
    new_berlin_wi = 'new_berlin_wi'
    northborough_ma = 'northborough_ma'
    orlando_fl = 'orlando_fl'
    phoneix_az = 'phoneix_az'
    pittsburgh_pa = 'pittsburgh_pa'
    reno_nv = 'reno_nv'
    sacramento_ca = 'sacramento_ca'
    salt_lake_city_ut = 'salt_lake_city_ut'
    seattle_wa = 'seattle_wa'
    st_louis_mo = 'st_louis_mo'
    windsor_ct = 'windsor_ct'
    newark_ny = 'newark_ny'
    south_brunswick_nj = 'south_brunswick_nj'
    scranton_pa = 'scranton_pa'
    wheeling_il = 'wheeling_il'


class SortDir(Enum):
    asc = 'asc'
    desc = 'desc'


class StatusCode(Enum):
    un = 'un'
    ac = 'ac'
    it = 'it'
    de = 'de'
    ex = 'ex'
    at = 'at'
    ny = 'ny'


class Tag(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: constr(min_length=1) = Field(
        ..., description='The tag name.', examples=['Fragile']
    )


class TagName(RootModel[constr(min_length=1)]):
    root: constr(min_length=1) = Field(
        ...,
        description='Tags are arbitrary strings that you can use to categorize shipments.  For example, you may want to use tags to distinguish between domestic and international shipments, or between insured and uninsured shipments.  Or maybe you want to create a tag for each of your customers so you can easily retrieve every shipment for a customer.\n',
        examples=['Fragile'],
        title='tag_name',
    )


class TagShipmentResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    shipment_id: SeId = Field(
        ..., description='A string that uniquely identifies the shipment'
    )
    tag: Tag = Field(
        ..., description='The tag that is now associated with this shipment'
    )


class TaxableEntityType(Enum):
    shipper = 'shipper'
    recipient = 'recipient'


class TokensGetEphemeralTokenResponseBodyYaml(BaseModel):
    redirect_url: Optional[str] = Field(
        None, description='The redirect url formatted with the requested token.'
    )
    token: Optional[str] = Field(
        None, description='The requested token that expires in 10 seconds.'
    )


class TrackEvent(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    carrier_detail_code: constr(min_length=1) = Field(
        ..., description='Carrier detail code', examples=['OT']
    )
    carrier_occurred_at: Optional[DateTime] = Field(
        None,
        description='Carrier timestamp for the event, it is assumed to be the local time of where the event occurred.',
    )
    carrier_status_code: constr(min_length=1) = Field(
        ..., description='Carrier status code', examples=[1]
    )
    carrier_status_description: constr(min_length=0) = Field(
        ...,
        description='carrier status description',
        examples=['Your item was delivered in or at the mailbox at 9:10 am on March'],
    )
    city_locality: constr(min_length=0) = Field(
        ..., description='City locality', examples=['AUSTIN']
    )
    company_name: Optional[constr(min_length=0)] = Field(
        None, description='Company Name', examples=['Stamps.com']
    )
    country_code: Optional[CountryCode] = None
    description: Optional[constr(min_length=0)] = Field(
        None, description='Event description', examples=['Delivered, In/At Mailbox']
    )
    event_code: Optional[constr(min_length=0)] = Field(None, description='Event Code')
    latitude: Optional[confloat(ge=-90.0, le=90.0)] = Field(
        None, description='Latitude coordinate of tracking event.'
    )
    longitude: Optional[confloat(ge=-180.0, le=180.0)] = Field(
        None, description='Longitude coordinate of tracking event.'
    )
    occurred_at: DateTime = Field(..., description='Timestamp for carrier event')
    postal_code: constr(min_length=0) = Field(
        ..., description='Postal code', examples=[78756]
    )
    signer: Optional[constr(min_length=0)] = Field(
        None, description='Signer information'
    )
    state_province: constr(min_length=2) = Field(
        ..., description='State province', examples=['TX']
    )
    status_code: StatusCode
    status_description: constr(min_length=1) = Field(
        ..., description='Event Status Description', examples=['In Transit']
    )


class TrackingNumber(RootModel[constr(min_length=1)]):
    root: constr(min_length=1) = Field(
        ...,
        description='A tracking number for a package. The format depends on the carrier.',
        examples=['1Z932R800392060079'],
        title='tracking_number',
    )


class TrackingStatus(Enum):
    unknown = 'unknown'
    in_transit = 'in_transit'
    error = 'error'
    delivered = 'delivered'


class UpdateAmazonBuyShippingRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    email: Optional[constr(min_length=1)] = Field(None, description='Email')


class UpdateDhlExpressSettingsRequestBody(DhlExpressAccountSettings):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class UpdateNewgisticsSettingsRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    include_barcode_with_order_number: Optional[bool] = None
    receive_email_on_manifest_processing: Optional[bool] = None


class UpdateWarehouseSettingsRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    is_default: Optional[bool] = Field(
        None, description='The default property on the warehouse.', examples=[True]
    )


class UpsInvoice(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    control_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the control'
    )
    invoice_amount: Optional[confloat(ge=0.0)] = None
    invoice_currency_code: Optional[str] = None
    invoice_date: Optional[datetime] = Field(None, description='invoice date')
    invoice_number: Optional[constr(min_length=1)] = Field(
        None, description='invoice number'
    )


class UpsPickupType(Enum):
    daily_pickup = 'daily_pickup'
    occasional_pickup = 'occasional_pickup'
    customer_counter = 'customer_counter'


class Url(RootModel[constr(min_length=1)]):
    root: constr(min_length=1) = Field(
        ...,
        description='A URL',
        examples=['http://api.shipengine.com/v1/labels/se-28529731'],
        title='url',
    )


class Uuid(RootModel[UUID]):
    root: UUID = Field(
        ...,
        description='A UUID (a.k.a. GUID) that uniquely identifies a resource',
        examples=['aa3d8e8e-462b-4476-9618-72db7f7b7009'],
        title='uuid',
    )


class ValidateAddress(Enum):
    no_validation = 'no_validation'
    validate_only = 'validate_only'
    validate_and_clean = 'validate_and_clean'


class ValidateShipmentFields(BaseModel):
    validate_address: Optional[ValidateAddress] = 'no_validation'


class ValidationStatus(Enum):
    valid = 'valid'
    invalid = 'invalid'
    has_warnings = 'has_warnings'
    unknown = 'unknown'


class VoidLabelResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    approved: bool = Field(
        ...,
        description='Indicates whether the attempt to void the label was successful',
    )
    message: constr(min_length=0) = Field(
        ..., examples=['Request for refund submitted.  This label has been voided.']
    )


class WebhookEvent(Enum):
    batch = 'batch'
    carrier_connected = 'carrier_connected'
    order_source_refresh_complete = 'order_source_refresh_complete'
    rate = 'rate'
    report_complete = 'report_complete'
    sales_orders_imported = 'sales_orders_imported'
    track = 'track'


class WeightUnit(Enum):
    pound = 'pound'
    ounce = 'ounce'
    gram = 'gram'
    kilogram = 'kilogram'


class SortBy(Enum):
    modified_at = 'modified_at'
    created_at = 'created_at'


class LabelIds(
    RootModel[List[constr(pattern=r'^se(-[a-z0-9]+)+$', min_length=1, max_length=25)]]
):
    root: List[constr(pattern=r'^se(-[a-z0-9]+)+$', min_length=1, max_length=25)] = (
        Field(..., description='Array of label ids')
    )


class AddFundsToCarrierRequestBody(MonetaryValue):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class AddFundsToCarrierResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    balance: MonetaryValue = Field(
        ..., description='The current balance of the account'
    )


class AddFundsToInsuranceRequestBody(MonetaryValue):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class AddFundsToInsuranceResponseBody(MonetaryValue):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class BatchResponseError(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    error: Optional[constr(min_length=1)] = Field(
        None,
        description='Error message associated with the shipment.',
        examples=['Recipient address has not been verified.'],
    )
    external_shipment_id: Optional[str] = Field(
        None, description='An external shipment id associated with the shipment'
    )
    shipment_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the shipment'
    )


class CollectOnDelivery(BaseModel):
    payment_amount: Optional[PaymentAmount] = None
    payment_type: Optional[CollectOnDeliveryPaymentType] = None


class ConnectAmazonBuyShippingRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    email: Email
    merchant_seller_id: constr(min_length=1)
    mws_auth_token: constr(min_length=1)
    nickname: constr(min_length=1) = Field(
        ...,
        description='Nickname to be associated with the account connection',
        examples=['Test Amazon Buy Shipping'],
    )


class ConnectCarrierResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    carrier_id: SeId = Field(
        ..., description='A string that uniquely identifies the carrier'
    )


class ConnectDhlExpressRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account_number: constr(min_length=1) = Field(..., description='Account number')
    country_code: Optional[CountryCode] = None
    nickname: constr(min_length=1) = Field(..., description='Nickname')
    password: Optional[constr(min_length=1)] = Field(
        None, description='Required if site id is provided'
    )
    site_id: Optional[constr(min_length=1)] = Field(
        None, description='Required if password is provided'
    )


class ConnectDhlExpressUkRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account_number: constr(min_length=1) = Field(..., description='Account number')
    nickname: constr(min_length=1) = Field(..., description='Nickname')
    password: constr(min_length=1) = Field(..., description='Password')
    site_id: SeId = Field(..., description='A string that uniquely identifies the site')


class ConnectFedexRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account_number: constr(min_length=1) = Field(..., description='Account number')
    address1: constr(min_length=1) = Field(..., description='Address')
    address2: Optional[constr(min_length=1)] = Field(None, description='Address')
    agree_to_eula: bool = Field(
        ...,
        description='Boolean signaling agreement to the Fedex End User License Agreement',
    )
    city: constr(min_length=1) = Field(..., description='The city')
    company: Optional[constr(min_length=1)] = Field(None, description='The company')
    country_code: constr(min_length=1) = Field(..., description='Country code')
    email: Email = Field(..., description='The email address')
    first_name: constr(min_length=1) = Field(..., description='First name')
    last_name: constr(min_length=1) = Field(..., description='Last name')
    meter_number: Optional[constr(min_length=1)] = Field(
        None, description='Meter number'
    )
    nickname: constr(min_length=1) = Field(..., description='Nickname')
    phone: constr(min_length=1) = Field(..., description='Phone number')
    postal_code: constr(min_length=1) = Field(..., description='Postal Code')
    state: constr(min_length=1) = Field(..., description='State')


class ConnectFedexUkRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account_number: constr(min_length=1) = Field(..., description='Account number')
    address1: constr(min_length=1) = Field(..., description='Address')
    address2: Optional[constr(min_length=1)] = Field(None, description='Address')
    agree_to_eula: bool = Field(
        ...,
        description='Boolean signaling agreement to the Fedex End User License Agreement',
    )
    city: constr(min_length=1) = Field(..., description='The city')
    company: Optional[constr(min_length=1)] = Field(None, description='The company')
    country_code: constr(min_length=1) = Field(..., description='Country code')
    email: Email = Field(..., description='The email address')
    first_name: constr(min_length=1) = Field(..., description='First name')
    last_name: constr(min_length=1) = Field(..., description='Last name')
    meter_number: Optional[constr(min_length=1)] = Field(
        None, description='Meter number'
    )
    nickname: constr(min_length=1) = Field(..., description='Nickname')
    phone: constr(min_length=1) = Field(..., description='Phone number')
    postal_code: constr(min_length=1) = Field(..., description='Postal Code')
    state: constr(min_length=1) = Field(..., description='State')


class ConnectFirstmileRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    mailer_id: SeId = Field(
        ..., description='A string that uniquely identifies the mailer'
    )
    nickname: constr(min_length=1) = Field(..., description='Nickname')
    password: constr(min_length=1) = Field(..., description='Password')
    profile_name: Optional[constr(min_length=1)] = Field(
        None, description='Profile name'
    )


class ConnectInsurerRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    email: Email
    policy_id: constr(min_length=1)


class ConnectRoyalMailRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account_number: constr(min_length=1) = Field(..., description='Account number')
    city: constr(min_length=1) = Field(..., description='City')
    company_name: Optional[constr(min_length=1)] = Field(
        None, description='Company name'
    )
    contact_name: constr(min_length=1) = Field(..., description='Contact name')
    email: Optional[Email] = Field(None, description='The email address')
    nickname: constr(min_length=1) = Field(..., description='Nickname')
    oba_email: Optional[Email] = Field(None, description='The oba email address')
    phone: Optional[constr(min_length=1)] = Field(None, description='Phone')
    postal_code: constr(min_length=1) = Field(..., description='Postal code')
    street_line1: Optional[constr(min_length=1)] = Field(
        None, description='Street line1'
    )
    street_line2: Optional[constr(min_length=1)] = Field(
        None, description='Street line2'
    )
    street_line3: Optional[constr(min_length=1)] = Field(
        None, description='Street line3'
    )


class ConnectSendleRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    api_key: constr(min_length=1) = Field(..., description='API key')
    nickname: constr(min_length=1) = Field(..., description='Nickname')
    sendle_id: SeId = Field(
        ..., description='A string that uniquely identifies the sendle'
    )


class ConnectUpsRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account_country_code: constr(min_length=1) = Field(
        ..., description='Account country code'
    )
    account_number: constr(min_length=1) = Field(..., description='Account number')
    account_postal_code: constr(min_length=1) = Field(
        ..., description='Account postal code'
    )
    address1: constr(min_length=1) = Field(..., description='Address Line 1')
    address2: Optional[constr(min_length=1)] = Field(None, description='Address Line 2')
    agree_to_technology_agreement: bool = Field(
        ...,
        description='The Agreement to the [UPS Technology Agreement](https://www.ups.com/assets/resources/media/UTA_with_EUR.pdf)',
    )
    city: constr(min_length=1) = Field(..., description='City')
    company: constr(min_length=1) = Field(..., description='Company')
    country_code: constr(min_length=1) = Field(..., description='Country code')
    email: Email = Field(..., description='The email address')
    first_name: constr(min_length=1) = Field(..., description='First name')
    invoice: Optional[UpsInvoice] = Field(None, description='The UPS invoice')
    invoice_amount: Optional[float] = Field(None, description='The invoice amount')
    invoice_currency_code: Optional[str] = Field(
        None, description='The invoice currency code'
    )
    last_name: constr(min_length=1) = Field(..., description='Last name')
    nickname: constr(min_length=1) = Field(..., description='Nickname')
    phone: constr(min_length=1) = Field(..., description='Phone')
    postal_code: constr(min_length=1) = Field(..., description='Postal code')
    state: constr(min_length=1) = Field(..., description='State')
    title: Optional[constr(min_length=1)] = Field(None, description='Title')


class ContactDetails(BaseModel):
    email: Email
    name: constr(min_length=1)
    phone: constr(min_length=7) = Field(..., description='Phone number associated')


class CreateBatchRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    batch_notes: Optional[constr(min_length=1)] = Field(
        None,
        description='Add custom messages for a particular batch',
        examples=['This is my batch'],
    )
    external_batch_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the external batch'
    )
    rate_ids: Optional[List[SeId]] = Field(
        None, description='Array of rate IDs used in the batch'
    )
    shipment_ids: Optional[List[SeId]] = Field(
        None, description='Array of shipment IDs used in the batch'
    )


class CreateLabelFromShipmentRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    display_scheme: Optional[DisplayScheme] = Field(
        'label', description='The display format that the label should be shown in.'
    )
    label_download_type: Optional[LabelDownloadType] = None
    label_format: Optional[LabelFormat] = 'pdf'
    label_layout: Optional[LabelLayout] = '4x6'
    validate_address: Optional[ValidateAddress] = None


class CreateManifestByObjectRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    carrier_id: SeId = Field(
        ..., description='A string that uniquely identifies the carrier'
    )
    excluded_label_ids: Optional[List[SeId]] = Field(
        None, description='The list of label ids to exclude from the manifest'
    )
    label_ids: Optional[List[SeId]] = Field(
        None, description='The list of label ids to include for the manifest'
    )
    ship_date: datetime = Field(
        ...,
        description='The ship date that the shipment will be sent out on',
        examples=['2018-09-23T15:00:00.000Z'],
    )
    warehouse_id: SeId = Field(
        ..., description='A string that uniquely identifies the warehouse'
    )


class CreateManifestLabelIdsRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    label_ids: List[SeId] = Field(
        ..., description='The list of label ids to include in the manifest'
    )


class CreateManifestRequestBody(
    RootModel[
        Union[CreateManifestByObjectRequestBody, CreateManifestLabelIdsRequestBody]
    ]
):
    root: Union[
        CreateManifestByObjectRequestBody, CreateManifestLabelIdsRequestBody
    ] = Field(..., title='create_manifest_request_body')


class CreateReturnLabelRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    charge_event: Optional[LabelChargeEvent] = Field(
        None, description='The label charge event.\n'
    )
    display_scheme: Optional[DisplayScheme] = Field(
        'label', description='The display format that the label should be shown in.'
    )
    label_download_type: Optional[LabelDownloadType] = 'url'
    label_format: Optional[LabelFormat] = Field(
        'pdf',
        description='The file format that you want the label to be in.  We recommend `pdf` format because it is supported by all carriers, whereas some carriers do not support the `png` or `zpl` formats.\n',
    )
    label_image_id: Optional[ImageId] = Field(
        None,
        description='The label image resource that was used to create a custom label image.',
    )
    label_layout: Optional[LabelLayout] = Field(
        '4x6',
        description='The layout (size) that you want the label to be in.  The `label_format` determines which sizes are allowed.  `4x6` is supported for all label formats, whereas `letter` (8.5" x 11") is only supported for `pdf` format.\n',
    )


class CreateTagResponseBody(Tag):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class CreateWebhookRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    event: WebhookEvent
    url: Url = Field(
        ...,
        description='The url that the webhook sends the request to',
        examples=['https://[YOUR ENDPOINT ID].x.requestbin.com'],
    )


class DeleteScheduledPickupResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    pickup_id: PickupResourceId


class Error(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    error_code: ErrorCode
    error_source: ErrorSource
    error_type: ErrorType
    message: constr(min_length=1) = Field(
        ...,
        description='An error message associated with the failed API call',
        examples=['Body of request cannot be null.'],
    )


class ErrorResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    errors: List[Error] = Field(
        ..., description='The errors associated with the failed API call'
    )
    request_id: Uuid = Field(
        ...,
        description='A UUID that uniquely identifies the request id.\nThis can be given to the support team to help debug non-trivial issues that may occur\n',
    )


class ErrorWithLabelIdResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    errors: List[Error] = Field(
        ..., description='The errors associated with the failed API call'
    )
    request_id: Uuid = Field(
        ...,
        description='A UUID that uniquely identifies the request id.\nThis can be given to the support team to help debug non-trivial issues that may occur\n',
    )


class FedexAccountSettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    is_primary_account: Optional[bool] = None
    letterhead_image: Optional[str] = None
    nickname: Optional[constr(min_length=1)] = Field(
        None, description='Account nickname'
    )
    pickup_type: Optional[FedexPickupType] = None
    signature_image: Optional[str] = None
    smart_post_endorsement: Optional[AncillaryServiceEndorsement] = None
    smart_post_hub: Optional[SmartPostHub] = None


class FedexAccountSettingsRequestBody(FedexAccountSettings):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class FedexSettingsResponseBody(FedexAccountSettingsRequestBody):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class GetInsuranceBalanceResponseBody(MonetaryValue):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class GetServicePointsRequest(RootModel[GetServicePointsRequestBody]):
    root: GetServicePointsRequestBody = Field(..., title='get_service_points_request')


class LabelDownload(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    href: Optional[Url] = Field(
        None, description='The URL of the linked resource, if any'
    )
    pdf: Optional[Url] = Field(None, description='The URL for the pdf generated label')
    png: Optional[Url] = Field(None, description='The URL for the png generated label')
    zpl: Optional[Url] = Field(None, description='The URL for the zpl generated label')


class ListCarrierServicesResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    services: Optional[List[Service]] = Field(
        None, description='An array of services associated with the carrier'
    )


class ListServicePointsResponseBody(BaseModel):
    errors: Optional[List[Error]] = Field(
        None, description='The errors associated with the failed API call'
    )
    lat: Optional[float] = Field(None, examples=[48.842608])
    long: Optional[float] = Field(None, examples=[0.032875])
    service_points: Optional[List[ServicePoint1]] = None


class ListTagsResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    tags: Optional[List[Tag]] = Field(
        None, description='The array of tags returned by the API call'
    )


class ManifestDownload(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    href: Optional[Url] = Field(
        None, description='The URL of the linked resource, if any'
    )


class ManifestRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    manifest_request_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies a manifest request'
    )
    status: Optional[ManifestRequestStatus] = None


class ManifestsRequests(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    manifest_requests: Optional[List[ManifestRequest]] = Field(
        None, description='Resulting manifest requests with statuses'
    )


class ModifyBatch(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    rate_ids: Optional[List[SeId]] = Field(
        None, description='Array of Rate IDs to be modifed on the batch'
    )
    shipment_ids: Optional[List[SeId]] = Field(
        None, description='The Shipment Ids to be modified on the batch'
    )


class OptionalLink(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    href: Optional[Url] = Field(
        None, description='The URL of the linked resource, if any'
    )
    type: Optional[constr(min_length=1)] = Field(
        None,
        description='The type of resource, or the type of relationship to the parent resource',
    )


class PackageType(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None,
        description='Provides a helpful description for the custom package.',
        examples=['Packaging for laptops'],
    )
    dimensions: Optional[Dimensions] = Field(
        None, description='The custom dimensions for the package.'
    )
    name: constr(min_length=1) = Field(..., examples=['laptop_box'])
    package_code: PackageCode
    package_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the package.'
    )


class PartialAddress(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    address_line1: Optional[constr(min_length=1)] = Field(
        None,
        description='The first line of the street address.  For some addresses, this may be the only line.  Other addresses may require 2 or 3 lines.\n',
        examples=['1999 Bishop Grandin Blvd.'],
    )
    address_line2: Optional[constr(min_length=1)] = Field(
        None,
        description='The second line of the street address.  For some addresses, this line may not be needed.\n',
        examples=['Unit 408'],
    )
    address_line3: Optional[constr(min_length=1)] = Field(
        None,
        description='The third line of the street address.  For some addresses, this line may not be needed.\n',
        examples=['Building #7'],
    )
    address_residential_indicator: Optional[AddressResidentialIndicator] = Field(
        'unknown',
        description='Indicates whether this is a residential address.',
        examples=['no'],
    )
    city_locality: Optional[constr(min_length=1)] = Field(
        None, description='The name of the city or locality', examples=['Winnipeg']
    )
    company_name: Optional[constr(min_length=1)] = Field(
        None,
        description='If this is a business address, then the company name should be specified here.\n',
        examples=['The Home Depot'],
    )
    country_code: Optional[CountryCode] = Field(
        None,
        description='The two-letter [ISO 3166-1 country code](https://en.wikipedia.org/wiki/ISO_3166-1)\n',
    )
    email: Optional[str] = Field(
        None,
        description='Email for the address owner.\n',
        examples=['example@example.com'],
    )
    name: Optional[constr(min_length=1)] = Field(
        None,
        description='The name of a contact person at this address.  This field may be set instead of - or in addition to - the `company_name` field.\n',
        examples=['John Doe'],
    )
    phone: Optional[constr(min_length=1)] = Field(
        None,
        description='The phone number of a contact person at this address.  The format of this phone number varies depending on the country.\n',
        examples=['+1 204-253-9411 ext. 123'],
    )
    postal_code: Optional[PostalCode] = None
    state_province: Optional[constr(min_length=1)] = Field(
        None,
        description='The state or province.  For some countries (including the U.S.) only abbreviations are allowed.  Other countries allow the full name or abbreviation.\n',
        examples=['Manitoba'],
    )


class PurchaseLabelWithoutShipment(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    display_scheme: Optional[DisplayScheme] = Field(
        'label', description='The display format that the label should be shown in.'
    )
    label_download_type: Optional[LabelDownloadType] = None
    label_format: Optional[LabelFormat] = 'pdf'
    label_layout: Optional[LabelLayout] = '4x6'
    validate_address: Optional[ValidateAddress] = None


class Rate(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    carrier_code: constr(min_length=1) = Field(..., description='carrier code')
    carrier_delivery_days: Optional[constr(min_length=1)] = Field(
        None, description='The carrier delivery days'
    )
    carrier_friendly_name: constr(min_length=1) = Field(
        ..., description='carrier friendly name'
    )
    carrier_id: SeId = Field(
        ..., description='A string that uniquely identifies the carrier'
    )
    carrier_nickname: constr(min_length=1) = Field(..., description='carrier nickname')
    confirmation_amount: MonetaryValue = Field(
        ..., description='The confirmation amount'
    )
    delivery_days: Optional[conint(ge=1)] = Field(
        None,
        description='The number of days estimated for delivery, this will show the _actual_ delivery\ntime if for example, the package gets shipped on a Friday\n',
        examples=[5],
    )
    error_messages: List[ErrorMessage] = Field(
        ..., description='The error messages', min_length=0
    )
    estimated_delivery_date: Optional[Date] = None
    guaranteed_service: bool = Field(
        ..., description='Indicates if the rate is guaranteed.'
    )
    insurance_amount: MonetaryValue = Field(..., description='The insurance amount')
    negotiated_rate: bool = Field(
        ..., description='Indicates if the rates been negotiated'
    )
    other_amount: MonetaryValue = Field(
        ..., description='Any other charges associated with this rate'
    )
    package_type: constr(min_length=1) = Field(
        ...,
        description='package type that this rate was estimated for',
        examples=['package'],
    )
    rate_id: SeId = Field(..., description='A string that uniquely identifies the rate')
    rate_type: RateType
    service_code: constr(min_length=1) = Field(
        ..., description='service code for the rate'
    )
    service_type: constr(min_length=1) = Field(..., description='service type')
    ship_date: Optional[datetime] = Field(None, description='ship date')
    shipping_amount: MonetaryValue = Field(..., description='The shipping amount')
    tax_amount: Optional[MonetaryValue] = Field(
        None,
        description='Tariff and additional taxes associated with an international shipment.',
    )
    trackable: bool = Field(..., description='Indicates if rate is trackable')
    validation_status: ValidationStatus
    warning_messages: List[WarningMessage] = Field(
        ..., description='The warning messages', min_length=0
    )
    zone: conint(ge=0) = Field(
        ...,
        description='Certain carriers base [their rates](https://blog.stamps.com/2017/09/08/usps-postal-zones/) off of\ncustom zones that vary depending upon the ship_to and ship_from location\n',
        examples=[6],
    )


class RateEstimate(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    carrier_code: constr(min_length=1) = Field(..., description='carrier code')
    carrier_delivery_days: Optional[constr(min_length=1)] = Field(
        None, description='The carrier delivery days'
    )
    carrier_friendly_name: constr(min_length=1) = Field(
        ..., description='carrier friendly name'
    )
    carrier_id: SeId = Field(
        ..., description='A string that uniquely identifies the carrier'
    )
    carrier_nickname: constr(min_length=1) = Field(..., description='carrier nickname')
    confirmation_amount: MonetaryValue = Field(
        ..., description='The confirmation amount'
    )
    delivery_days: Optional[conint(ge=1)] = Field(
        None,
        description='The number of days estimated for delivery, this will show the _actual_ delivery\ntime if for example, the package gets shipped on a Friday\n',
        examples=[5],
    )
    error_messages: List[ErrorMessage] = Field(
        ..., description='The error messages', min_length=0
    )
    estimated_delivery_date: Optional[Date] = None
    guaranteed_service: bool = Field(
        ..., description='Indicates if the rate is guaranteed.'
    )
    insurance_amount: MonetaryValue = Field(..., description='The insurance amount')
    negotiated_rate: bool = Field(
        ..., description='Indicates if the rates been negotiated'
    )
    other_amount: MonetaryValue = Field(
        ..., description='Any other charges associated with this rate'
    )
    package_type: constr(min_length=1) = Field(
        ...,
        description='package type that this rate was estimated for',
        examples=['package'],
    )
    rate_type: RateType
    service_code: constr(min_length=1) = Field(
        ..., description='service code for the rate'
    )
    service_type: constr(min_length=1) = Field(..., description='service type')
    ship_date: Optional[datetime] = Field(None, description='ship date')
    shipping_amount: MonetaryValue = Field(..., description='The shipping amount')
    tax_amount: Optional[MonetaryValue] = Field(
        None,
        description='Tariff and additional taxes associated with an international shipment.',
    )
    trackable: bool = Field(..., description='Indicates if rate is trackable')
    validation_status: ValidationStatus
    warning_messages: List[WarningMessage] = Field(
        ..., description='The warning messages', min_length=0
    )
    zone: conint(ge=0) = Field(
        ...,
        description='Certain carriers base [their rates](https://blog.stamps.com/2017/09/08/usps-postal-zones/) off of\ncustom zones that vary depending upon the ship_to and ship_from location\n',
        examples=[6],
    )


class RateEstimateByCarrierId(BaseModel):
    carrier_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the carrier'
    )


class RateEstimateByCarrierIds(BaseModel):
    carrier_ids: Optional[List[SeId]] = Field(
        None, description='Array of Carrier Ids', min_length=1
    )


class RateRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    calculate_tax_amount: Optional[bool] = Field(
        None, description='Calculate the duties and tariffs for cross border shipments.'
    )
    carrier_ids: List[SeId] = Field(
        ..., description='Array of carrier ids to get rates for', min_length=1
    )
    is_return: Optional[bool] = Field(
        None, description="Indicate if it's a return shipment"
    )
    package_types: Optional[List[constr(min_length=1)]] = None
    preferred_currency: Optional[Currency] = None
    service_codes: Optional[List[constr(min_length=1)]] = None


class RateRequestByShipmentIds(BaseModel):
    shipment_ids: List[SeId] = Field(..., description='The array of shipment IDs')


class RateRequestOptions(BaseModel):
    rate_options: Optional[RateRequestBody] = Field(
        None, description='The rate options'
    )


class RateRequestRateOptions(BaseModel):
    rate_options: Optional[RateRequestBody] = Field(
        None, description='The rate options'
    )


class RatesInformation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    created_at: Optional[SeId] = Field(None, description='When the rate was created')
    errors: Optional[List[Error]] = None
    invalid_rates: Optional[List[Rate]] = Field(
        [], description='An array of invalid shipment rates'
    )
    rate_request_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the rate request'
    )
    rates: Optional[List[Rate]] = Field(None, description='An array of shipment rates')
    shipment_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the shipment'
    )
    status: Optional[RateResponseStatus] = None


class RemoveFromBatchRequestBody(ModifyBatch):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class TaxIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    identifier_type: IdentifierType
    issuing_authority: str = Field(
        ...,
        description='The authority that issued this tax. This must be a valid 2 character ISO 3166 Alpha 2 country code.',
    )
    taxable_entity_type: TaxableEntityType
    value: str = Field(..., description='The value of the identifier')


class TrackingInformation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    actual_delivery_date: Optional[DateTime] = None
    carrier_code: Optional[CarrierCode] = None
    carrier_detail_code: Optional[constr(min_length=1)] = Field(
        None, description='Carrier detail code', examples=['OT']
    )
    carrier_id: Optional[SeId] = None
    carrier_status_code: Optional[constr(min_length=1)] = Field(
        None, description='Carrier status code', examples=[1]
    )
    carrier_status_description: Optional[constr(min_length=0)] = Field(
        None,
        description='carrier status description',
        examples=['Your item was delivered in or at the mailbox at 9:10 am on March'],
    )
    estimated_delivery_date: Optional[DateTime] = None
    events: Optional[List[TrackEvent]] = Field(
        None,
        description='The events that have occured during the lifetime of this tracking number.',
    )
    exception_description: Optional[constr(min_length=0)] = Field(
        None, description='Exception description'
    )
    ship_date: Optional[DateTime] = None
    status_code: Optional[StatusCode] = None
    status_description: Optional[constr(min_length=0)] = Field(
        None, description='Status description', examples=['Delivered']
    )
    tracking_number: Optional[TrackingNumber] = None
    tracking_url: Optional[str] = Field(
        None,
        description='Carrier Tracking Url, if available',
        examples=['https://www.fedex.com/fedextrack/?action=track&trackingnumber=1234'],
    )


class UpdateFedexSettingsRequestBody(FedexAccountSettings):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class UpdatePackageTypeRequestBody(PackageType):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class UpdateShipmentFields(BaseModel):
    validate_address: Optional[ValidateAddress] = 'no_validation'


class UpdateWebhookRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    url: Optional[Url] = Field(
        None,
        description='The url that the wehbook sends the request',
        examples=['https://[YOUR ENDPOINT ID].x.requestbin.com'],
    )


class UpsAccountSettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account_postal_code: Optional[constr(min_length=5)] = Field(
        None, description='account postal code'
    )
    invoice: Optional[UpsInvoice] = Field(None, description='The invoice')
    is_primary_account: Optional[bool] = Field(
        None, description='Indicates if this is the primary UPS account'
    )
    mail_innovations_cost_center: Optional[constr(min_length=0)] = Field(
        None, description='mail innovations cost center'
    )
    mail_innovations_endorsement: Optional[AncillaryServiceEndorsement] = None
    nickname: Optional[constr(min_length=1)] = Field(None, description='nickname')
    pickup_type: Optional[UpsPickupType] = None
    use_carbon_neutral_shipping_program: Optional[bool] = Field(
        None, description='The use carbon neutral shipping program'
    )
    use_consolidation_services: Optional[bool] = Field(
        None, description='The use consolidation services'
    )
    use_ground_freight_pricing: Optional[bool] = Field(
        None, description='The use ground freight pricing'
    )
    use_negotiated_rates: Optional[bool] = Field(
        None, description='The use negotiated rates'
    )
    use_order_number_on_mail_innovations_labels: Optional[bool] = Field(
        None, description='The use order number on mail innovations labels'
    )


class UpsSettingsResponseBody(UpsAccountSettings):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class Webhook(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    event: Optional[WebhookEvent] = None
    url: Optional[Url] = Field(
        None,
        description='The url that the webhook sends the request to',
        examples=['https://[YOUR ENDPOINT ID].x.requestbin.com'],
    )
    webhook_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the webhook'
    )


class Weight(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    unit: WeightUnit
    value: PositiveFloat = Field(..., description='The weight, in the specified unit')


class AddToBatchRequestBody(ModifyBatch):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class Address(PartialAddress):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: constr(min_length=1) = Field(
        ...,
        description='The name of a contact person at this address.  This field may be set instead of - or in addition to - the `company_name` field.\n',
        examples=['John Doe'],
    )
    phone: constr(min_length=1) = Field(
        ...,
        description='The phone number of a contact person at this address.  The format of this phone number varies depending on the country.\n',
        examples=['+1 204-253-9411 ext. 123'],
    )
    address_line1: constr(min_length=1) = Field(
        ...,
        description='The first line of the street address.  For some addresses, this may be the only line.  Other addresses may require 2 or 3 lines.\n',
        examples=['1999 Bishop Grandin Blvd.'],
    )
    city_locality: constr(min_length=1) = Field(
        ..., description='The name of the city or locality', examples=['Winnipeg']
    )
    state_province: constr(min_length=1) = Field(
        ...,
        description='The state or province.  For some countries (including the U.S.) only abbreviations are allowed.  Other countries allow the full name or abbreviation.\n',
        examples=['Manitoba'],
    )
    postal_code: PostalCode
    country_code: CountryCode = Field(
        ...,
        description='The two-letter [ISO 3166-1 country code](https://en.wikipedia.org/wiki/ISO_3166-1)\n',
    )
    address_residential_indicator: AddressResidentialIndicator = Field(
        ...,
        description='Indicates whether this is a residential address.',
        examples=['no'],
    )


class AddressToValidate(PartialAddress):
    model_config = ConfigDict(
        extra='forbid',
    )
    address_line1: constr(min_length=1) = Field(
        ...,
        description='The first line of the street address.  For some addresses, this may be the only line.  Other addresses may require 2 or 3 lines.\n',
        examples=['1999 Bishop Grandin Blvd.'],
    )
    city_locality: constr(min_length=1) = Field(
        ..., description='The name of the city or locality', examples=['Winnipeg']
    )
    state_province: constr(min_length=1) = Field(
        ...,
        description='The state or province.  For some countries (including the U.S.) only abbreviations are allowed.  Other countries allow the full name or abbreviation.\n',
        examples=['Manitoba'],
    )
    country_code: CountryCode = Field(
        ...,
        description='The two-letter [ISO 3166-1 country code](https://en.wikipedia.org/wiki/ISO_3166-1)\n',
    )


class AddressValidationResult(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    matched_address: Address = Field(
        ..., description='The matched address found by the Shipengine API'
    )
    messages: List[ResponseMessage] = Field(
        ...,
        description='The list of messages that were generated during the address validation request.',
    )
    original_address: Address = Field(
        ..., description='The original address that was sent for validation'
    )
    status: AddressValidationStatus


class AdvancedShipmentOptions(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    bill_to_account: Optional[str] = Field(
        None,
        description='This field is used to [bill shipping costs to a third party](https://www.shipengine.com/docs/shipping/bill-to-third-party/).  This field must be used in conjunction with the `bill_to_country_code`, `bill_to_party`, and `bill_to_postal_code` fields.\n',
    )
    bill_to_country_code: Optional[CountryCode] = Field(
        None,
        description='The two-letter [ISO 3166-1 country code](https://en.wikipedia.org/wiki/ISO_3166-1) of the third-party that is responsible for shipping costs.\n',
    )
    bill_to_party: Optional[BillToParty] = Field(
        None,
        description='Indicates whether to bill shipping costs to the recipient or to a third-party.  When billing to a third-party, the `bill_to_account`, `bill_to_country_code`, and `bill_to_postal_code` fields must also be set.\n',
    )
    bill_to_postal_code: Optional[str] = Field(
        None,
        description='The postal code of the third-party that is responsible for shipping costs.\n',
    )
    collect_on_delivery: Optional[CollectOnDelivery] = None
    contains_alcohol: Optional[bool] = Field(
        False, description='Indicates that the shipment contains alcohol.'
    )
    custom_field1: Optional[constr(max_length=100)] = Field(
        None,
        description='An arbitrary field that can be used to store information about the shipment.\n',
    )
    custom_field2: Optional[constr(max_length=100)] = Field(
        None,
        description='An arbitrary field that can be used to store information about the shipment.\n',
    )
    custom_field3: Optional[constr(max_length=100)] = Field(
        None,
        description='An arbitrary field that can be used to store information about the shipment.\n',
    )
    delivered_duty_paid: Optional[bool] = Field(
        False,
        description='Indicates that the shipper is paying the international delivery duties for this shipment.  This option is supported by UPS, FedEx, and DHL Express.\n',
    )
    dry_ice: Optional[bool] = Field(
        False, description='Indicates if the shipment contain dry ice'
    )
    dry_ice_weight: Optional[Weight] = Field(
        None, description='The weight of the dry ice in the shipment'
    )
    fedex_freight: Optional[FedexFreight] = Field(
        None, description='Provide details for the Fedex freight service'
    )
    freight_class: Optional[str] = Field(
        None,
        description='The National Motor Freight Traffic Association [freight class](http://www.nmfta.org/pages/nmfc?AspxAutoDetectCookieSupport=1), such as "77.5", "110", or "250".\n',
        examples=[77.5],
    )
    non_machinable: Optional[bool] = Field(
        False,
        description='Indicates that the package cannot be processed automatically because it is too large or irregularly shaped. This is primarily for USPS shipments.  See [Section 1.2 of the USPS parcel standards](https://pe.usps.com/text/dmm300/101.htm#ep1047495) for details.\n',
    )
    origin_type: Optional[OriginType] = None
    saturday_delivery: Optional[bool] = Field(
        False, description='Enables Saturday delivery, if supported by the carrier.'
    )
    shipper_release: Optional[bool] = None
    third_party_consignee: Optional[bool] = Field(
        False,
        description='Third Party Consignee option is a value-added service that allows the shipper to supply goods without commercial invoices being attached',
    )
    use_ups_ground_freight_pricing: Optional[bool] = Field(
        None,
        description='Whether to use [UPS Ground Freight pricing](https://www.shipengine.com/docs/shipping/ups-ground-freight/).  If enabled, then a `freight_class` must also be specified.\n',
    )


class Batch(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    batch_errors_url: OptionalLink = Field(
        ..., description='Link to batch errors endpoint'
    )
    batch_id: SeId = Field(
        ..., description='A string that uniquely identifies the batch'
    )
    batch_labels_url: OptionalLink = Field(
        ..., description='Link to batch labels query'
    )
    batch_notes: str = Field(
        ...,
        description='Custom notes you can add for each created batch',
        examples=['Batch for morning shipment'],
    )
    batch_number: constr(min_length=0) = Field(..., description='The batch number.')
    batch_shipments_url: OptionalLink = Field(
        ..., description='The batch shipments endpoint'
    )
    completed: conint(ge=0) = Field(
        ..., description='The number of labels generated in the batch', examples=[1]
    )
    count: conint(ge=0) = Field(
        ...,
        description='The total of errors, warnings, and completed properties',
        examples=[2],
    )
    created_at: DateTime = Field(
        ..., description='The date and time the batch was created in ShipEngine'
    )
    errors: conint(ge=0) = Field(
        ...,
        description='The number of errors that occurred while generating the batch',
        examples=[2],
    )
    external_batch_id: constr(min_length=0) = Field(
        ..., description='A string that uniquely identifies the external batch'
    )
    form_download: OptionalLink = Field(
        ..., description='The form download for any customs that are needed'
    )
    forms: conint(ge=0) = Field(
        ...,
        description='The number of forms for customs that are available for download',
        examples=[3],
    )
    label_download: LabelDownload = Field(
        ..., description='The label download for the batch'
    )
    label_format: LabelFormat
    label_layout: LabelLayout = Field(..., description='label layout')
    processed_at: DateTime = Field(
        ..., description='The date and time the batch was processed in ShipEngine'
    )
    status: BatchStatus
    warnings: conint(ge=0) = Field(
        ...,
        description='The number of warnings that occurred while generating the batch',
        examples=[1],
    )


class BulkRate(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    created_at: DateTime
    errors: List[Error] = Field(
        ...,
        description='An array of errors that were returned while retrieving the bulk rate',
    )
    rate_request_id: SeId = Field(
        ..., description='A string that uniquely identifies the rate request'
    )
    shipment_id: SeId = Field(
        ..., description='A string that uniquely identifies the shipment'
    )
    status: RateResponseStatus


class CalculateRatesRequestBody(RateRequestOptions):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class Carrier(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account_number: Optional[constr(min_length=1)] = Field(
        None,
        description='The account number that the carrier is connected to.',
        examples=['account_570827'],
    )
    balance: Optional[confloat(ge=0.0)] = Field(
        None, description='Current available balance', examples=[3799.52]
    )
    carrier_code: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the carrier.'
    )
    carrier_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the carrier.'
    )
    friendly_name: Optional[constr(min_length=1)] = Field(
        None, description='Screen readable name', examples=['Stamps.com']
    )
    has_multi_package_supporting_services: Optional[bool] = Field(
        None, description='Carrier supports multiple packages per shipment'
    )
    nickname: Optional[constr(min_length=1)] = Field(
        None,
        description='Nickname given to the account when initially setting up the carrier.',
        examples=['ShipEngine Account - Stamps.com'],
    )
    options: Optional[List[CarrierAdvancedOption]] = Field(
        None, description='A list of options that are available to that carrier'
    )
    packages: Optional[List[PackageType]] = Field(
        None, description='A list of package types that are supported by the carrier'
    )
    primary: Optional[bool] = Field(
        None,
        description='Is this the primary carrier that is used by default when no carrier is specified in label/shipment creation',
    )
    requires_funded_amount: Optional[bool] = Field(
        None,
        description='Indicates whether the carrier requires funding to use its services',
    )
    services: Optional[List[Service]] = Field(
        None, description='A list of services that are offered by the carrier'
    )
    supports_label_messages: Optional[bool] = Field(
        None,
        description='The carrier supports adding custom label messages to an order.',
    )


class CompareBulkRatesRequestBody(RateRequestRateOptions):
    model_config = ConfigDict(
        extra='forbid',
    )
    rate_options: RateRequestBody = Field(..., description='The rate options')


class CompareBulkRatesResponseBody(RootModel[List[BulkRate]]):
    root: List[BulkRate] = Field(
        ...,
        description='A bulk rate response body',
        title='compare_bulk_rates_response_body',
    )


class ConnectCarrierRequestBody(
    RootModel[
        Union[
            ConnectAccessWorldwideRequestBody,
            ConnectAmazonBuyShippingRequestBody,
            ConnectAmazonShippingUk,
            ConnectApcRequestBody,
            ConnectAsendiaRequestBody,
            ConnectAustraliaPostRequestBody,
            ConnectCanadaPostRequestBody,
            ConnectDhlEcommerceRequestBody,
            ConnectDhlExpressRequestBody,
            ConnectDhlExpressAuRequestBody,
            ConnectDhlExpressCaRequestBody,
            ConnectDhlExpressUkRequestBody,
            ConnectDpdRequestBody,
            ConnectEndiciaRequestBody,
            ConnectFedexRequestBody,
            ConnectFedexUkRequestBody,
            ConnectFirstmileRequestBody,
            ConnectImexRequestBody,
            ConnectNewgisticsRequestBody,
            ConnectOntracRequestBody,
            ConnectPurolatorRequestBody,
            ConnectRoyalMailRequestBody,
            ConnectRrDonnelleyRequestBody,
            ConnectSekoRequestBody,
            ConnectSendleRequestBody,
            ConnectStampsRequestBody,
            ConnectUpsRequestBody,
        ]
    ]
):
    root: Union[
        ConnectAccessWorldwideRequestBody,
        ConnectAmazonBuyShippingRequestBody,
        ConnectAmazonShippingUk,
        ConnectApcRequestBody,
        ConnectAsendiaRequestBody,
        ConnectAustraliaPostRequestBody,
        ConnectCanadaPostRequestBody,
        ConnectDhlEcommerceRequestBody,
        ConnectDhlExpressRequestBody,
        ConnectDhlExpressAuRequestBody,
        ConnectDhlExpressCaRequestBody,
        ConnectDhlExpressUkRequestBody,
        ConnectDpdRequestBody,
        ConnectEndiciaRequestBody,
        ConnectFedexRequestBody,
        ConnectFedexUkRequestBody,
        ConnectFirstmileRequestBody,
        ConnectImexRequestBody,
        ConnectNewgisticsRequestBody,
        ConnectOntracRequestBody,
        ConnectPurolatorRequestBody,
        ConnectRoyalMailRequestBody,
        ConnectRrDonnelleyRequestBody,
        ConnectSekoRequestBody,
        ConnectSendleRequestBody,
        ConnectStampsRequestBody,
        ConnectUpsRequestBody,
    ] = Field(..., title='connect_carrier_request_body')


class CreateBatchResponseBody(Batch):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class CreateLabelFromRateRequestBody(PurchaseLabelWithoutShipment):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class CreatePackageTypeRequestBody(PackageType):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class CreatePackageTypeResponseBody(PackageType):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class CreateShipmentResponseBodyFields(BaseModel):
    address_validation: Optional[AddressValidationResult] = Field(
        None, description='The address validation'
    )
    errors: Optional[List[constr(min_length=1)]] = Field(
        None, description='An array of errors that occurred while creating shipment.'
    )


class CreateWebhookResponseBody(Webhook):
    model_config = ConfigDict(
        extra='forbid',
    )
    webhook_id: SeId = Field(
        ..., description='A string that uniquely identifies the webhook'
    )
    url: Url = Field(
        ...,
        description='The url that the webhook sends the request to',
        examples=['https://[YOUR ENDPOINT ID].x.requestbin.com'],
    )
    event: WebhookEvent


class CustomsItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    country_of_origin: Optional[CountryCode] = Field(
        None,
        description='The two-letter [ISO 3166-1 country code](https://en.wikipedia.org/wiki/ISO_3166-1) where this item originated\n',
    )
    customs_item_id: SeId = Field(
        ..., description='A string that uniquely identifies the customs item'
    )
    description: Optional[constr(max_length=100)] = Field(
        None, description='A description of the item'
    )
    harmonized_tariff_code: Optional[str] = Field(
        None,
        description='The [Harmonized Tariff Code](https://en.wikipedia.org/wiki/Harmonized_System) of this item.',
        examples=[3926.1],
    )
    quantity: Optional[conint(ge=0)] = Field(
        0, description='The quantity of this item in the shipment.'
    )
    sku: Optional[str] = Field(
        None, description='The SKU (Stock Keeping Unit) of the customs item'
    )
    sku_description: Optional[str] = Field(
        None, description="Description of the Custom Item's SKU"
    )
    unit_of_measure: Optional[str] = None
    value: Optional[MonetaryValue] = Field(
        None, description='The declared customs value of each item'
    )
    weight: Optional[Weight] = Field(None, description='The item weight')


class DeletePickupByIdResponseBody(
    ErrorResponseBody, DeleteScheduledPickupResponseBody
):
    pass


class DeprecatedManifest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    carrier_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the carrier'
    )
    created_at: Optional[datetime] = Field(
        None,
        description='The date-time that the manifest was created',
        examples=['2019-07-12T13:37:39.050Z'],
    )
    form_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the form'
    )
    label_ids: Optional[List[SeId]] = Field(
        None, description='An array of the label ids used in this manifest.'
    )
    manifest_download: Optional[ManifestDownload] = None
    manifest_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the manifest'
    )
    ship_date: Optional[datetime] = Field(
        None,
        description='The date-time that the manifests shipments will be picked up',
        examples=['2019-07-12T13:37:39.050Z'],
    )
    shipments: Optional[conint(ge=1)] = Field(
        None,
        description='The number of shipments that are included in this manifest',
        examples=[100],
    )
    submission_id: Optional[constr(min_length=1)] = Field(
        None,
        description='A string that uniquely identifies the submission',
        examples=['9475711899564878915476'],
    )
    warehouse_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the warehouse'
    )


class EstimateRatesResponseBody(RootModel[List[RateEstimate]]):
    root: List[RateEstimate] = Field(
        ...,
        description='A rate estimate response body',
        title='estimate_rates_response_body',
    )


class GetBatchByExternalIdResponseBody(Batch):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class GetBatchByIdResponseBody(Batch):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class GetCarrierByIdResponseBody(Carrier):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class GetCarrierSettingsResponseBody(
    RootModel[
        Union[
            DhlExpressSettingsResponseBody,
            FedexSettingsResponseBody,
            UpsSettingsResponseBody,
        ]
    ]
):
    root: Union[
        DhlExpressSettingsResponseBody,
        FedexSettingsResponseBody,
        UpsSettingsResponseBody,
    ] = Field(..., title='get_carrier_settings_response_body')


class GetPackageTypeByIdResponseBody(PackageType):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class GetRateByIdResponseBody(Rate):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class GetTrackingLogFromLabelResponseBody(TrackingInformation):
    model_config = ConfigDict(
        extra='forbid',
    )
    tracking_number: TrackingNumber
    status_code: StatusCode
    carrier_status_code: constr(min_length=1) = Field(
        ..., description='Carrier status code', examples=[1]
    )
    estimated_delivery_date: DateTime
    events: List[TrackEvent] = Field(
        ...,
        description='The events that have occured during the lifetime of this tracking number.',
    )


class GetTrackingLogResponseBody(TrackingInformation):
    model_config = ConfigDict(
        extra='forbid',
    )
    tracking_number: TrackingNumber
    tracking_url: str = Field(
        ...,
        description='Carrier Tracking Url, if available',
        examples=['https://www.fedex.com/fedextrack/?action=track&trackingnumber=1234'],
    )
    status_code: StatusCode
    carrier_code: CarrierCode
    carrier_id: SeId
    carrier_detail_code: constr(min_length=1) = Field(
        ..., description='Carrier detail code', examples=['OT']
    )
    carrier_status_code: constr(min_length=1) = Field(
        ..., description='Carrier status code', examples=[1]
    )
    estimated_delivery_date: DateTime
    events: List[TrackEvent] = Field(
        ...,
        description='The events that have occured during the lifetime of this tracking number.',
    )


class GetWebhookByIdResponseBody(Webhook):
    model_config = ConfigDict(
        extra='forbid',
    )
    webhook_id: SeId = Field(
        ..., description='A string that uniquely identifies the webhook'
    )
    url: Url = Field(
        ...,
        description='The url that the webhook sends the request to',
        examples=['https://[YOUR ENDPOINT ID].x.requestbin.com'],
    )
    event: WebhookEvent


class InternationalShipmentOptions(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    contents: PackageContents = Field(
        ...,
        description='The type of contents in this shipment.  This may impact import duties or customs treatment.',
    )
    customs_items: Optional[List[CustomsItem]] = Field(
        [],
        description='Customs declarations for each item in the shipment.',
        min_length=0,
    )
    non_delivery: NonDelivery = Field(
        ..., description='Indicates what to do if a package is unable to be delivered.'
    )


class Link(OptionalLink):
    model_config = ConfigDict(
        extra='forbid',
    )
    href: Url = Field(..., description='The URL of the linked resource, if any')


class ListCarrierPackageTypesResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    packages: Optional[List[PackageType]] = Field(
        None, description='An array of custom package types'
    )


class ListCarriersResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    carriers: List[Carrier] = Field(..., description='The carrier response body')


class ListPackageTypesResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    packages: Optional[List[PackageType]] = Field(
        None, description='An array of custom package types'
    )


class ListShipmentRatesResponseBody(RatesInformation):
    model_config = ConfigDict(
        extra='forbid',
    )
    rates: List[Rate] = Field(..., description='An array of shipment rates')
    invalid_rates: List[Rate] = Field(
        ..., description='An array of invalid shipment rates'
    )
    rate_request_id: SeId = Field(
        ..., description='A string that uniquely identifies the rate request'
    )
    shipment_id: SeId = Field(
        ..., description='A string that uniquely identifies the shipment'
    )
    created_at: SeId = Field(..., description='When the rate was created')
    status: RateResponseStatus
    errors: List[Error]


class ListWebhooksResponseBody(RootModel[List[Webhook]]):
    root: List[Webhook] = Field(
        ...,
        description='A webhook list response body',
        title='list_webhooks_response_body',
    )


class Manifest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    carrier_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the carrier'
    )
    created_at: Optional[datetime] = Field(
        None,
        description='The date-time that the manifest was created',
        examples=['2019-07-12T13:37:39.050Z'],
    )
    form_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the form'
    )
    label_ids: Optional[List[SeId]] = Field(
        None, description='An array of the label ids used in this manifest.'
    )
    manifest_download: Optional[ManifestDownload] = None
    manifest_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the manifest'
    )
    ship_date: Optional[datetime] = Field(
        None,
        description='The date-time that the manifests shipments will be picked up',
        examples=['2019-07-12T13:37:39.050Z'],
    )
    shipments: Optional[conint(ge=1)] = Field(
        None,
        description='The number of shipments that are included in this manifest',
        examples=[100],
    )
    submission_id: Optional[constr(min_length=1)] = Field(
        None,
        description='A string that uniquely identifies the submission',
        examples=['9475711899564878915476'],
    )
    warehouse_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the warehouse'
    )


class Manifests(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    manifests: Optional[List[Manifest]] = Field(None, description='Resulting Manifests')


class Package(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    content_description: Optional[constr(min_length=1, max_length=35)] = Field(
        None,
        description='A short description of the package content. Required for shipments moving to, from, and through Mexico.\n',
        examples=['Hand knitted wool socks'],
    )
    dimensions: Optional[Dimensions] = Field(None, description='The package dimensions')
    external_package_id: Optional[constr(min_length=1)] = Field(
        None, description='An external package id.'
    )
    form_download: Optional[OptionalLink] = Field(
        None, description='The form download for any customs that are needed'
    )
    insured_value: Optional[MonetaryValue] = Field(
        default_factory=lambda: MonetaryValue.model_validate(
            [{'amount': 0, 'currency': 'usd'}]
        ),
        description='The insured value of the package.  Requires the `insurance_provider` field of the shipment to be set.\n',
    )
    label_download: Optional[LabelDownload] = Field(
        None, description='The label download for the package'
    )
    label_messages: Optional[LabelMessages] = None
    package_code: Optional[PackageCode] = Field(
        None,
        description='The [package type](https://www.shipengine.com/docs/reference/list-carrier-packages/), such as `thick_envelope`, `small_flat_rate_box`, `large_package`, etc.  The code `package` indicates a custom or unknown package type.\n',
    )
    package_id: Optional[SeId] = Field(
        None,
        description='A string that uniquely identifies this [package type](https://www.shipengine.com/docs/reference/list-carrier-packages/)',
    )
    sequence: Optional[int] = Field(None, description='Package sequence')
    tracking_number: Optional[TrackingNumber] = Field(
        None,
        description='The tracking number for the package.  The format depends on the carrier.\n',
    )
    weight: Weight = Field(..., description='The package weight')


class PaginationLink(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    first: Link = Field(
        ...,
        description='The link to the first page of results.  This object will _always_ have an `href` field. If there are no results, then the first page will contain an empty array of items.\n',
    )
    last: Link = Field(
        ...,
        description='The link to the final page of results.  This object will _always_ have an `href` field. If there are no results, then the final page will contain an empty array of items.\n',
    )
    next: OptionalLink = Field(
        ...,
        description='The link to the next page of results.  The `href` field will only be set when the `page` is less than `pages`.\n',
    )
    prev: OptionalLink = Field(
        ...,
        description='The link to the previous page of results.  The `href` field will only be set when the `page` is 2 or greater.\n',
    )


class ParseAddressRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    address: Optional[PartialAddress] = Field(
        None,
        description="You can optionally provide any already-known address values. For example, you may already know the recipient's name, city, and country, and only want to parse the street address into separate lines.\n",
    )
    text: constr(min_length=1) = Field(
        ...,
        description='The unstructured text that contains address-related entities',
        examples=[
            'Margie McMiller at 3800 North Lamar suite 200 in austin, tx.  The zip code there is 78652.'
        ],
    )


class ParseAddressResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    address: PartialAddress = Field(
        ...,
        description='The parsed address.  This address may not be complete, depending on how much information was included in the text and how confident the API is about each recognized entity.\n\n> **Note:** The address-recognition API does not currently perform any validation of the parsed address, so we recommend that you use the [address-validation API](https://www.shipengine.com/docs/addresses/validation/) to ensure that the address is correct.\n',
    )
    entities: List[RecognizedEntity] = Field(
        ...,
        description='All of the entities that were recognized in the text. An "entity" is a single piece of data, such as a city, a postal code, or an address line.  Each entity includes the original text and the parsed value.\n',
        min_length=0,
    )
    score: confloat(ge=0.0, le=1.0) = Field(
        ...,
        description='A confidence score between zero and one that indicates how certain the API is that it understood the text.\n',
    )


class Pickup(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cancelled_at: Optional[DateTime] = Field(
        None,
        description='The date and time that the pickup was cancelled in ShipEngine.',
    )
    carrier_id: Optional[SeId] = Field(
        None, description='The carrier_id associated with the pickup'
    )
    confirmation_number: Optional[str] = Field(
        None,
        description='The carrier confirmation number for the scheduled pickup.',
        examples=['292513CL4A3'],
    )
    contact_details: Optional[ContactDetails] = None
    created_at: Optional[DateTime] = Field(
        None, description='The date and time that the pickup was created in ShipEngine.'
    )
    label_ids: Optional[List[SeId]] = Field(
        None, description='Label IDs that will be included in the pickup request'
    )
    pickup_address: Optional[Address] = None
    pickup_id: Optional[PickupResourceId] = None
    pickup_notes: Optional[constr(min_length=0)] = Field(
        None,
        description='Used by some carriers to give special instructions for a package pickup',
    )
    pickup_window: Optional[PickupWindow] = None
    pickup_windows: Optional[List[PickupWindows]] = Field(
        None,
        description='An array of available pickup windows. Carriers can return multiple times that they will pickup packages.\n',
    )
    warehouse_id: Optional[SeId] = Field(
        None, description='The warehouse_id associated with the pickup'
    )


class PickupResponseBody(Pickup):
    model_config = ConfigDict(
        extra='forbid',
    )
    pickup_id: PickupResourceId
    label_ids: List[SeId] = Field(
        ..., description='Label IDs that will be included in the pickup request'
    )
    created_at: DateTime = Field(
        ..., description='The date and time that the pickup was created in ShipEngine.'
    )
    carrier_id: SeId = Field(
        ..., description='The carrier_id associated with the pickup'
    )
    warehouse_id: SeId = Field(
        ..., description='The warehouse_id associated with the pickup'
    )
    pickup_address: Address
    contact_details: ContactDetails
    pickup_window: PickupWindow
    confirmation_number: str = Field(
        ...,
        description='The carrier confirmation number for the scheduled pickup.',
        examples=['292513CL4A3'],
    )


class RateEstimateOptions(BaseModel):
    address_residential_indicator: Optional[AddressResidentialIndicator] = None
    confirmation: Optional[DeliveryConfirmation] = None
    dimensions: Optional[Dimensions] = Field(
        None, description='The dimensions of the package'
    )
    from_city_locality: Optional[constr(min_length=1)] = Field(
        None, description='from postal code', examples=['Austin']
    )
    from_country_code: Optional[CountryCode] = None
    from_postal_code: Optional[PostalCode] = None
    from_state_province: Optional[constr(min_length=1)] = Field(
        None, description='From state province', examples=['Austin']
    )
    ship_date: Optional[DateTime] = Field(None, description='ship date')
    to_city_locality: Optional[constr(min_length=1)] = Field(
        None,
        description='The city locality the package is being shipped to',
        examples=['Austin'],
    )
    to_country_code: Optional[CountryCode] = None
    to_postal_code: Optional[PostalCode] = None
    to_state_province: Optional[constr(min_length=1)] = Field(
        None, description='To state province', examples=['Houston']
    )
    weight: Optional[Weight] = Field(None, description='The weight of the package')


class RateResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    rate_response: Optional[RatesInformation] = Field(
        None, description='The rates response'
    )


class SchedulePickupRequestBody(Pickup):
    model_config = ConfigDict(
        extra='forbid',
    )
    contact_details: ContactDetails
    label_ids: List[SeId] = Field(
        ..., description='Label IDs that will be included in the pickup request'
    )
    pickup_window: PickupWindow


class SchedulePickupResponseBody(Pickup, ErrorResponseBody):
    pass


class ShippingAddress(Address, PartialShippingAddress):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class UpdateUpsSettingsRequestBody(UpsAccountSettings):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class ValidateAddressRequestBody(RootModel[List[AddressToValidate]]):
    root: List[AddressToValidate] = Field(
        ...,
        description='An address validation request body',
        title='validate_address_request_body',
    )


class ValidateAddressResponseBody(RootModel[List[AddressValidationResult]]):
    root: List[AddressValidationResult] = Field(
        ...,
        description='An address validation response body',
        title='validate_address_response_body',
    )


class Warehouse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    created_at: Optional[datetime] = Field(
        None,
        description='Timestamp that indicates when the warehouse was created',
        examples=['2019-06-25T18:12:35.583Z'],
    )
    is_default: Optional[bool] = Field(
        False,
        description='Designates which single warehouse is the default on the account',
    )
    name: Optional[constr(min_length=1)] = Field(
        None, description='Name of the warehouse', examples=['Zero Cool HQ']
    )
    origin_address: Optional[Address] = Field(
        None, description='The origin address of the warehouse'
    )
    return_address: Optional[Address] = Field(
        None, description='The return address associated with the warehouse'
    )
    warehouse_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the warehouse'
    )


class CreateManifestResponseBody(
    Manifests, ManifestsRequests, DeprecatedManifest, ErrorWithLabelIdResponseBody
):
    model_config = ConfigDict(
        extra='forbid',
    )
    manifest_id: SeId = Field(
        ..., description='A string that uniquely identifies the manifest'
    )
    form_id: SeId = Field(..., description='A string that uniquely identifies the form')
    created_at: datetime = Field(
        ...,
        description='The date-time that the manifest was created',
        examples=['2019-07-12T13:37:39.050Z'],
    )
    ship_date: datetime = Field(
        ...,
        description='The date-time that the manifests shipments will be picked up',
        examples=['2019-07-12T13:37:39.050Z'],
    )
    shipments: conint(ge=1) = Field(
        ...,
        description='The number of shipments that are included in this manifest',
        examples=[100],
    )
    warehouse_id: SeId = Field(
        ..., description='A string that uniquely identifies the warehouse'
    )
    submission_id: constr(min_length=1) = Field(
        ...,
        description='A string that uniquely identifies the submission',
        examples=['9475711899564878915476'],
    )
    carrier_id: SeId = Field(
        ..., description='A string that uniquely identifies the carrier'
    )
    manifest_download: ManifestDownload


class CreateWarehouseRequestBody(Warehouse):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: constr(min_length=1) = Field(
        ..., description='Name of the warehouse', examples=['Zero Cool HQ']
    )
    origin_address: Address = Field(
        ..., description='The origin address of the warehouse'
    )


class CreateWarehouseResponseBody(Warehouse):
    model_config = ConfigDict(
        extra='forbid',
    )
    warehouse_id: SeId = Field(
        ..., description='A string that uniquely identifies the warehouse'
    )
    name: constr(min_length=1) = Field(
        ..., description='Name of the warehouse', examples=['Zero Cool HQ']
    )
    created_at: datetime = Field(
        ...,
        description='Timestamp that indicates when the warehouse was created',
        examples=['2019-06-25T18:12:35.583Z'],
    )
    origin_address: Address = Field(
        ..., description='The origin address of the warehouse'
    )
    return_address: Address = Field(
        ..., description='The return address associated with the warehouse'
    )


class EstimateRatesRequestBody(RateEstimateOptions):
    model_config = ConfigDict(
        extra='forbid',
    )
    from_country_code: CountryCode
    from_postal_code: PostalCode
    from_city_locality: constr(min_length=1) = Field(
        ..., description='from postal code', examples=['Austin']
    )
    from_state_province: constr(min_length=1) = Field(
        ..., description='From state province', examples=['Austin']
    )
    to_country_code: CountryCode
    to_postal_code: PostalCode
    to_city_locality: constr(min_length=1) = Field(
        ...,
        description='The city locality the package is being shipped to',
        examples=['Austin'],
    )
    to_state_province: constr(min_length=1) = Field(
        ..., description='To state province', examples=['Houston']
    )
    weight: Weight = Field(..., description='The weight of the package')
    ship_date: DateTime = Field(..., description='ship date')


class GetCarriersResponseBody(ListCarriersResponseBody, ErrorResponseBody):
    pass


class GetManifestByIdResponseBody(Manifest):
    model_config = ConfigDict(
        extra='forbid',
    )
    manifest_id: SeId = Field(
        ..., description='A string that uniquely identifies the manifest'
    )
    form_id: SeId = Field(..., description='A string that uniquely identifies the form')
    created_at: datetime = Field(
        ...,
        description='The date-time that the manifest was created',
        examples=['2019-07-12T13:37:39.050Z'],
    )
    ship_date: datetime = Field(
        ...,
        description='The date-time that the manifests shipments will be picked up',
        examples=['2019-07-12T13:37:39.050Z'],
    )
    shipments: conint(ge=1) = Field(
        ...,
        description='The number of shipments that are included in this manifest',
        examples=[100],
    )
    warehouse_id: SeId = Field(
        ..., description='A string that uniquely identifies the warehouse'
    )
    submission_id: constr(min_length=1) = Field(
        ...,
        description='A string that uniquely identifies the submission',
        examples=['9475711899564878915476'],
    )
    carrier_id: SeId = Field(
        ..., description='A string that uniquely identifies the carrier'
    )
    manifest_download: ManifestDownload
    label_ids: List[SeId] = Field(
        ..., description='An array of the label ids used in this manifest.'
    )


class GetPickupByIdResponseBody(PickupResponseBody, ErrorResponseBody):
    pass


class GetWarehouseByIdResponseBody(Warehouse):
    model_config = ConfigDict(
        extra='forbid',
    )
    warehouse_id: SeId = Field(
        ..., description='A string that uniquely identifies the warehouse'
    )
    name: constr(min_length=1) = Field(
        ..., description='Name of the warehouse', examples=['Zero Cool HQ']
    )
    created_at: datetime = Field(
        ...,
        description='Timestamp that indicates when the warehouse was created',
        examples=['2019-06-25T18:12:35.583Z'],
    )
    origin_address: Address = Field(
        ..., description='The origin address of the warehouse'
    )
    return_address: Address = Field(
        ..., description='The return address associated with the warehouse'
    )


class ListBatchErrorsResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    errors: List[BatchResponseError] = Field(
        ..., description='The errors currently associated with the batch'
    )
    links: PaginationLink


class ListBatchesResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    batches: List[Batch] = Field(..., description='Batch List', min_length=0)
    links: PaginationLink
    page: conint(ge=1) = Field(
        ..., description='The page that is currently being read', examples=[1]
    )
    pages: conint(ge=1) = Field(
        ...,
        description='The total number of batch pages the API call returned',
        examples=[10],
    )
    total: conint(ge=0) = Field(
        ...,
        description='The total number of batches the API call returned',
        examples=[10],
    )


class ListManifestsResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    links: PaginationLink = Field(
        ..., description='Helpful links to other pages of results'
    )
    manifests: List[Manifest] = Field(
        ..., description='The list of available manifests'
    )
    page: conint(ge=1) = Field(
        ..., description='Current page of the list manifests results', examples=[3]
    )
    pages: conint(ge=1) = Field(
        ...,
        description='Total number of pages for list manifests results',
        examples=[4],
    )
    total: conint(ge=0) = Field(
        ..., description='The total number of manifests returned', examples=[3]
    )


class ListPickupResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    links: PaginationLink = Field(
        ..., description='Helpful links to other pages of results'
    )
    page: conint(ge=1) = Field(
        ..., description='Current page of the list pickups results', examples=[3]
    )
    pages: conint(ge=1) = Field(
        ..., description='Total number of pages for list pickups results', examples=[4]
    )
    pickups: List[Pickup] = Field(
        ..., description="An array of pickups associated with the user's account."
    )
    total: conint(ge=0) = Field(
        ..., description='The total number of pickups returned', examples=[3]
    )


class ListWarehousesResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    warehouses: List[Warehouse] = Field(
        ..., description='The array of warehouses returned by the API call'
    )


class PagedListResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    links: PaginationLink
    page: conint(ge=1) = Field(
        ...,
        description='The current page number of results.  For example, if there are 80 results, and the page size is 25, then `page` could be 1, 2, 3, or 4.  The first three pages would contain 25 items each, and the fourth page would contain the five remaining items.',
        examples=[1],
    )
    pages: conint(ge=0) = Field(
        ...,
        description='The total number of pages of results.  For example, if there are 80 results, and the page size is 25, then `pages` would be 4.  The first three pages would contain 25 items each, and the fourth page would contain the five remaining items.  If there are no results, then `pages` will be zero.',
        examples=[4],
    )
    total: conint(ge=0) = Field(
        ...,
        description='The total number of items across all pages of results',
        examples=[2750],
    )


class PartialShipment(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    advanced_options: Optional[AdvancedShipmentOptions] = Field(
        None, description='Advanced shipment options.  These are entirely optional.'
    )
    carrier_id: Optional[SeId] = Field(
        None, description='The carrier account that is billed for the shipping charges'
    )
    confirmation: Optional[DeliveryConfirmation] = Field(
        'none',
        description='The type of delivery confirmation that is required for this shipment.',
    )
    created_at: Optional[DateTime] = Field(
        None,
        description='The date and time that the shipment was created in ShipEngine.',
    )
    customs: Optional[InternationalShipmentOptions] = Field(
        None,
        description='Customs information.  This is usually only needed for international shipments.\n',
    )
    external_order_id: Optional[str] = Field(
        None, description='ID that the Order Source assigned'
    )
    external_shipment_id: Optional[constr(max_length=50)] = Field(
        None,
        description='A unique user-defined key to identify a shipment.  This can be used to retrieve the shipment.\n\n> **Warning:** The `external_shipment_id` is limited to 50 characters. Any additional characters will be truncated.\n',
    )
    insurance_provider: Optional[InsuranceProvider] = Field(
        'none',
        description='The insurance provider to use for any insured packages in the shipment.\n',
    )
    items: Optional[List[ShipmentItem]] = Field(
        [],
        description='Describe the packages included in this shipment as related to potential metadata that was imported from\nexternal order sources\n',
    )
    modified_at: Optional[DateTime] = Field(
        None,
        description='The date and time that the shipment was created or last modified.',
    )
    order_source_code: Optional[OrderSourceName] = None
    origin_type: Optional[OriginType] = Field(
        None,
        description='Indicates if the package will be picked up or dropped off by the carrier',
    )
    packages: Optional[List[Package]] = Field(
        None,
        description="The packages in the shipment.\n\n> **Note:** Some carriers only allow one package per shipment.  If you attempt to create a multi-package shipment for a carrier that doesn't allow it, an error will be returned.\n",
        min_length=1,
    )
    return_to: Optional[ShippingAddress] = Field(
        None,
        description='The return address for this shipment.  Defaults to the `ship_from` address.\n',
    )
    service_code: Optional[ServiceCode] = Field(
        None,
        description='The [carrier service](https://www.shipengine.com/docs/shipping/use-a-carrier-service/) used to ship the package, such as `fedex_ground`, `usps_first_class_mail`, `flat_rate_envelope`, etc.\n',
    )
    ship_date: Optional[Date] = Field(
        None,
        description='The date that the shipment was (or will be) shippped.  ShipEngine will take the day of week into consideration. For example, if the carrier does not operate on Sundays, then a package that would have shipped on Sunday will ship on Monday instead.\n',
    )
    ship_from: Optional[ShippingAddress] = Field(
        None,
        description="The shipment's origin address. If you frequently ship from the same location, consider [creating a warehouse](https://www.shipengine.com/docs/reference/create-warehouse/).  Then you can simply specify the `warehouse_id` rather than the complete address each time.\n",
    )
    ship_to: Optional[ShippingAddress] = Field(
        None, description="The recipient's mailing address"
    )
    shipment_id: Optional[SeId] = Field(
        None, description='A string that uniquely identifies the shipment'
    )
    shipment_number: Optional[constr(max_length=50)] = Field(
        None,
        description='A non-unique user-defined number used to identify a shipment.  If undefined, this will match the external_shipment_id of the shipment.\n\n> **Warning:** The `shipment_number` is limited to 50 characters. Any additional characters will be truncated.\n',
    )
    shipment_status: Optional[ShipmentStatus] = Field(
        'pending', description='The current status of the shipment'
    )
    tags: Optional[List[Tag]] = Field(
        [],
        description='Arbitrary tags associated with this shipment.  Tags can be used to categorize shipments, and shipments can be queried by their tags.\n',
        min_length=0,
    )
    tax_identifiers: Optional[List[TaxIdentifier]] = None
    total_weight: Optional[Weight] = Field(
        None, description='The combined weight of all packages in the shipment'
    )
    warehouse_id: Optional[SeId] = Field(
        None,
        description='The [warehouse](https://www.shipengine.com/docs/shipping/ship-from-a-warehouse/) that the shipment is being shipped from.  Either `warehouse_id` or `ship_from` must be specified.\n',
    )


class Shipment(PartialShipment):
    model_config = ConfigDict(
        extra='forbid',
    )
    shipment_id: SeId = Field(
        ..., description='A string that uniquely identifies the shipment'
    )
    carrier_id: SeId = Field(
        ..., description='The carrier account that is billed for the shipping charges'
    )
    service_code: ServiceCode = Field(
        ...,
        description='The [carrier service](https://www.shipengine.com/docs/shipping/use-a-carrier-service/) used to ship the package, such as `fedex_ground`, `usps_first_class_mail`, `flat_rate_envelope`, etc.\n',
    )
    ship_date: Date = Field(
        ...,
        description='The date that the shipment was (or will be) shippped.  ShipEngine will take the day of week into consideration. For example, if the carrier does not operate on Sundays, then a package that would have shipped on Sunday will ship on Monday instead.\n',
    )
    created_at: DateTime = Field(
        ...,
        description='The date and time that the shipment was created in ShipEngine.',
    )
    modified_at: DateTime = Field(
        ...,
        description='The date and time that the shipment was created or last modified.',
    )
    shipment_status: ShipmentStatus = Field(
        ..., description='The current status of the shipment'
    )
    ship_to: ShippingAddress = Field(..., description="The recipient's mailing address")
    ship_from: ShippingAddress = Field(
        ...,
        description="The shipment's origin address. If you frequently ship from the same location, consider [creating a warehouse](https://www.shipengine.com/docs/reference/create-warehouse/).  Then you can simply specify the `warehouse_id` rather than the complete address each time.\n",
    )
    warehouse_id: SeId = Field(
        ...,
        description='The [warehouse](https://www.shipengine.com/docs/shipping/ship-from-a-warehouse/) that the shipment is being shipped from.  Either `warehouse_id` or `ship_from` must be specified.\n',
    )
    return_to: ShippingAddress = Field(
        ...,
        description='The return address for this shipment.  Defaults to the `ship_from` address.\n',
    )
    confirmation: DeliveryConfirmation = Field(
        ...,
        description='The type of delivery confirmation that is required for this shipment.',
    )
    customs: InternationalShipmentOptions = Field(
        ...,
        description='Customs information.  This is usually only needed for international shipments.\n',
    )
    advanced_options: AdvancedShipmentOptions = Field(
        ..., description='Advanced shipment options.  These are entirely optional.'
    )
    insurance_provider: InsuranceProvider = Field(
        ...,
        description='The insurance provider to use for any insured packages in the shipment.\n',
    )
    tags: List[Tag] = Field(
        ...,
        description='Arbitrary tags associated with this shipment.  Tags can be used to categorize shipments, and shipments can be queried by their tags.\n',
        min_length=0,
    )
    packages: List[Package] = Field(
        ...,
        description="The packages in the shipment.\n\n> **Note:** Some carriers only allow one package per shipment.  If you attempt to create a multi-package shipment for a carrier that doesn't allow it, an error will be returned.\n",
        min_length=1,
    )
    total_weight: Weight = Field(
        ..., description='The combined weight of all packages in the shipment'
    )


class UpdateCarrierSettingsRequestBody(
    RootModel[
        Union[
            UpdateDhlExpressSettingsRequestBody,
            UpdateFedexSettingsRequestBody,
            UpdateNewgisticsSettingsRequestBody,
            UpdateUpsSettingsRequestBody,
            UpdateAmazonBuyShippingRequestBody,
        ]
    ]
):
    root: Union[
        UpdateDhlExpressSettingsRequestBody,
        UpdateFedexSettingsRequestBody,
        UpdateNewgisticsSettingsRequestBody,
        UpdateUpsSettingsRequestBody,
        UpdateAmazonBuyShippingRequestBody,
    ] = Field(..., title='update_carrier_settings_request_body')


class UpdateShipmentRequestBody(PartialShipment, UpdateShipmentFields):
    model_config = ConfigDict(
        extra='forbid',
    )
    ship_to: ShippingAddress = Field(..., description="The recipient's mailing address")
    ship_from: ShippingAddress = Field(
        ...,
        description="The shipment's origin address. If you frequently ship from the same location, consider [creating a warehouse](https://www.shipengine.com/docs/reference/create-warehouse/).  Then you can simply specify the `warehouse_id` rather than the complete address each time.\n",
    )


class UpdateWarehouseRequestBody(Warehouse):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: constr(min_length=1) = Field(
        ..., description='Name of the warehouse', examples=['Zero Cool HQ']
    )
    origin_address: Address = Field(
        ..., description='The origin address of the warehouse'
    )


class AddressValidatingShipment(ValidateShipmentFields, PartialShipment):
    model_config = ConfigDict(
        extra='forbid',
    )
    shipment_id: SeId = Field(
        ..., description='A string that uniquely identifies the shipment'
    )
    carrier_id: SeId = Field(
        ..., description='The carrier account that is billed for the shipping charges'
    )
    service_code: ServiceCode = Field(
        ...,
        description='The [carrier service](https://www.shipengine.com/docs/shipping/use-a-carrier-service/) used to ship the package, such as `fedex_ground`, `usps_first_class_mail`, `flat_rate_envelope`, etc.\n',
    )
    ship_to: ShippingAddress = Field(..., description="The recipient's mailing address")
    ship_from: ShippingAddress = Field(
        ...,
        description="The shipment's origin address. If you frequently ship from the same location, consider [creating a warehouse](https://www.shipengine.com/docs/reference/create-warehouse/).  Then you can simply specify the `warehouse_id` rather than the complete address each time.\n",
    )


class CalculateRatesResponseBody(PartialShipment, RateResponse):
    model_config = ConfigDict(
        extra='forbid',
    )
    rate_response: RatesInformation = Field(..., description='The rates response')
    shipment_id: SeId = Field(
        ..., description='A string that uniquely identifies the shipment'
    )
    ship_date: Date = Field(
        ...,
        description='The date that the shipment was (or will be) shippped.  ShipEngine will take the day of week into consideration. For example, if the carrier does not operate on Sundays, then a package that would have shipped on Sunday will ship on Monday instead.\n',
    )
    created_at: DateTime = Field(
        ...,
        description='The date and time that the shipment was created in ShipEngine.',
    )
    modified_at: DateTime = Field(
        ...,
        description='The date and time that the shipment was created or last modified.',
    )
    shipment_status: ShipmentStatus = Field(
        ..., description='The current status of the shipment'
    )
    return_to: ShippingAddress = Field(
        ...,
        description='The return address for this shipment.  Defaults to the `ship_from` address.\n',
    )
    confirmation: DeliveryConfirmation = Field(
        ...,
        description='The type of delivery confirmation that is required for this shipment.',
    )
    customs: InternationalShipmentOptions = Field(
        ...,
        description='Customs information.  This is usually only needed for international shipments.\n',
    )
    advanced_options: AdvancedShipmentOptions = Field(
        ..., description='Advanced shipment options.  These are entirely optional.'
    )
    insurance_provider: InsuranceProvider = Field(
        ...,
        description='The insurance provider to use for any insured packages in the shipment.\n',
    )
    tags: List[Tag] = Field(
        ...,
        description='Arbitrary tags associated with this shipment.  Tags can be used to categorize shipments, and shipments can be queried by their tags.\n',
        min_length=0,
    )
    packages: List[Package] = Field(
        ...,
        description="The packages in the shipment.\n\n> **Note:** Some carriers only allow one package per shipment.  If you attempt to create a multi-package shipment for a carrier that doesn't allow it, an error will be returned.\n",
        min_length=1,
    )
    total_weight: Weight = Field(
        ..., description='The combined weight of all packages in the shipment'
    )


class CreateAndValidateShipment(PartialShipment, CreateShipmentResponseBodyFields):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class CreateShipmentsRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    shipments: List[AddressValidatingShipment] = Field(
        ..., description='An array of shipments to be created.', min_length=1
    )


class CreateShipmentsResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    has_errors: bool = Field(
        ..., description='Indicates if errors occured while creating the shipments'
    )
    shipments: List[CreateAndValidateShipment] = Field(
        ..., description='An array of shipments that were created.'
    )


class GetPickupsResponseBody(ListPickupResponseBody, ErrorResponseBody):
    pass


class GetShipmentByExternalIdResponseBody(Shipment):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class GetShipmentByIdResponseBody(Shipment):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class Label(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    alternative_identifiers: Optional[List[AlternativeIdentifier]] = Field(
        None,
        description='Additional information some carriers may provide by which to identify a given label in their system. \n',
    )
    batch_id: Optional[SeId] = Field(
        None,
        description='If this label was created as part of a [batch](https://www.shipengine.com/docs/labels/bulk/), then this is the unique ID of that batch.\n',
    )
    carrier_code: Optional[CarrierCode] = Field(
        None,
        description='The [shipping carrier](https://www.shipengine.com/docs/carriers/setup/) who will ship the package, such as `fedex`, `dhl_express`, `stamps_com`, etc.\n',
    )
    carrier_id: Optional[SeId] = Field(
        None,
        description='The unique ID of the [carrier account](https://www.shipengine.com/docs/carriers/setup/) that was used to create this label\n',
    )
    charge_event: Optional[LabelChargeEvent] = Field(
        None, description='The label charge event.\n'
    )
    created_at: Optional[DateTime] = Field(
        None, description='The date and time that the label was created in ShipEngine.'
    )
    display_scheme: Optional[DisplayScheme] = Field(
        'label', description='The display format that the label should be shown in.'
    )
    form_download: Optional[Link] = Field(
        None,
        description='The link to download the customs form (a.k.a. commercial invoice) for this shipment, if any.  Forms are in PDF format. This field is null if the shipment does not require a customs form, or if the carrier does not support it.\n',
    )
    insurance_claim: Optional[Link] = Field(
        None,
        description='The link to submit an insurance claim for the shipment.  This field is null if the shipment is not insured or if the insurance provider does not support online claim submission.\n',
    )
    insurance_cost: Optional[MonetaryValue] = Field(
        None,
        description='The insurance cost for this package.  Add this to the `shipment_cost` field to get the total cost.\n',
    )
    is_international: Optional[bool] = Field(
        None,
        description='Indicates whether this is an international shipment.  That is, the originating country and destination country are different.\n',
    )
    is_return_label: Optional[bool] = Field(
        None,
        description='Indicates whether this is a return label.  You may also want to set the `rma_number` so you know what is being returned.\n',
    )
    label_download: Optional[LabelDownload] = None
    label_download_type: Optional[LabelDownloadType] = 'url'
    label_format: Optional[LabelFormat] = Field(
        'pdf',
        description='The file format that you want the label to be in.  We recommend `pdf` format because it is supported by all carriers, whereas some carriers do not support the `png` or `zpl` formats.\n',
    )
    label_id: Optional[SeId] = Field(
        None,
        description='A string that uniquely identifies the label. This ID is generated by ShipEngine when the label is created.\n',
    )
    label_image_id: Optional[ImageId] = Field(
        None,
        description='The label image resource that was used to create a custom label image.',
    )
    label_layout: Optional[LabelLayout] = Field(
        '4x6',
        description='The layout (size) that you want the label to be in.  The `label_format` determines which sizes are allowed.  `4x6` is supported for all label formats, whereas `letter` (8.5" x 11") is only supported for `pdf` format.\n',
    )
    outbound_label_id: Optional[SeId] = Field(
        None,
        description='The `label_id` of the original (outgoing) label that the return label is for. This associates the two labels together, which is\nrequired by some carriers.\n',
    )
    package_code: Optional[PackageCode] = Field(
        None,
        description='The [package type](https://www.shipengine.com/docs/reference/list-carrier-packages/), such as `thick_envelope`, `small_flat_rate_box`, `large_package`, etc.  The code `package` indicates a custom or unknown package type.\n',
    )
    packages: Optional[List[Package]] = Field(
        None,
        description="The label's package(s).\n\n> **Note:** Some carriers only allow one package per label.  If you attempt to create a multi-package label for a carrier that doesn't allow it, an error will be returned.\n",
    )
    rma_number: Optional[str] = Field(
        None,
        description='An optional Return Merchandise Authorization number.  This field is useful for return labels.  You can set it to any string value.\n',
    )
    service_code: Optional[ServiceCode] = Field(
        None,
        description='The [carrier service](https://www.shipengine.com/docs/shipping/use-a-carrier-service/) used to ship the package, such as `fedex_ground`, `usps_first_class_mail`, `flat_rate_envelope`, etc.\n',
    )
    ship_date: Optional[Date] = Field(
        None,
        description='The date that the package was (or will be) shippped.  ShipEngine will take the day of week into consideration. For example, if the carrier does not operate on Sundays, then a package that would have shipped on Sunday will ship on Monday instead.\n',
    )
    shipment: Optional[Shipment] = Field(
        None, description='The shipment information used to generate the label'
    )
    shipment_cost: Optional[MonetaryValue] = Field(
        None,
        description='The cost of shipping, delivery confirmation, and other carrier charges.  This amount **does not** include insurance costs.\n',
    )
    shipment_id: Optional[SeId] = Field(
        None,
        description='The shipment that this label is for.  ShipEngine can create a shipment for you automatically when you [create a label](https://www.shipengine.com/docs/labels/create-a-label/), or you can [create your own shipment](https://www.shipengine.com/docs/shipping/create-a-shipment/) and then [use it to print a label](https://www.shipengine.com/docs/labels/create-from-shipment/)\n',
    )
    status: Optional[LabelStatus] = None
    test_label: Optional[bool] = Field(
        False,
        description='Indicate if this label is being used only for testing purposes. If true, then no charge will be added to your account.',
    )
    trackable: Optional[bool] = Field(
        None,
        description='Indicates whether the shipment is trackable, in which case the `tracking_status` field will reflect the current status and each package will have a `tracking_number`.\n',
    )
    tracking_number: Optional[constr(min_length=1)] = Field(
        None,
        description='The tracking number for the package. Tracking number formats vary across carriers.',
        examples=['782758401696'],
    )
    tracking_status: Optional[TrackingStatus] = Field(
        None,
        description='The current status of the package, such as `in_transit` or `delivered`',
    )
    validate_address: Optional[ValidateAddress] = 'validate_and_clean'
    voided: Optional[bool] = Field(
        None,
        description='Indicates whether the label has been [voided](https://www.shipengine.com/docs/labels/voiding/)\n',
    )
    voided_at: Optional[DateTime] = Field(
        None,
        description='The date and time that the label was [voided](https://www.shipengine.com/docs/labels/voiding/), or `null` if the label has not been voided\n',
    )


class ListLabelsResponseBody(PagedListResponseBody):
    model_config = ConfigDict(
        extra='forbid',
    )
    labels: List[Label] = Field(
        ...,
        description='The labels that matched the query criteria.  If no matching labels were found, then this array is empty; otherwise, it contains one page of results.  The last page of results may have fewer labels than the `page_size`.\n',
        min_length=0,
    )


class ListShipmentsResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    links: PaginationLink
    page: conint(ge=1) = Field(..., examples=['????'])
    pages: conint(ge=1)
    shipments: List[Shipment] = Field(
        ..., description='The list of shipments returned by the api call'
    )
    total: conint(ge=0) = Field(
        ...,
        description='Total number of shipments returned by the api call',
        examples=[1990],
    )


class ParseShipmentRequestBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    shipment: Optional[PartialShipment] = Field(
        None,
        description='You can optionally provide a `shipment` object containing any already-known values. For example, you probably already know the `ship_from` address, and you may also already know what carrier and service you want to use.\n',
    )
    text: constr(min_length=1) = Field(
        ...,
        description='The unstructured text that contains shipping-related entities',
        examples=[
            "I have a 4oz package that's 5x10x14in, and I need to ship it to Margie McMiller at 3800 North Lamar suite 200 in austin, tx 78652. Please send it via USPS first class and require an adult signature. It also needs to be insured for $400.\n"
        ],
    )


class ParseShipmentResponseBody(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    entities: List[RecognizedEntity] = Field(
        ...,
        description='All of the entities that were recognized in the text. An "entity" is a single piece of data, such as a city, a postal code, a carrier name, or a package weight.  Each entity includes the original text and the parsed value.\n',
        min_length=0,
    )
    score: confloat(ge=0.0, le=1.0) = Field(
        ...,
        description='A confidence score between zero and one that indicates how certain the API is that it understood the text.\n',
    )
    shipment: PartialShipment = Field(
        ...,
        description='The parsed shipment.  This shipment may not be complete, depending on how much information was included in the text and how confident the API is about each recognized entity.\n\n> **Note:** The shipment-recognition API does not currently perform any validation of the parsed addresses, so we recommend that you use the [address-validation API](https://www.shipengine.com/docs/addresses/validation/) to ensure that the addresses are correct.\n',
    )


class RateRequestByShipments(BaseModel):
    shipments: List[AddressValidatingShipment] = Field(
        ...,
        description='The array of shipments to get bulk rate estimates for',
        min_length=1,
    )


class ShipmentRequest(BaseModel):
    shipment: Optional[AddressValidatingShipment] = Field(
        None, description='The shipment object'
    )


class UpdateShipmentResponseBody(CreateAndValidateShipment):
    model_config = ConfigDict(
        extra='forbid',
    )
    errors: List[constr(min_length=1)] = Field(
        ..., description='An array of errors that occurred while creating shipment.'
    )
    address_validation: AddressValidationResult = Field(
        ..., description='The address validation'
    )
    shipment_id: SeId = Field(
        ..., description='A string that uniquely identifies the shipment'
    )
    carrier_id: SeId = Field(
        ..., description='The carrier account that is billed for the shipping charges'
    )
    service_code: ServiceCode = Field(
        ...,
        description='The [carrier service](https://www.shipengine.com/docs/shipping/use-a-carrier-service/) used to ship the package, such as `fedex_ground`, `usps_first_class_mail`, `flat_rate_envelope`, etc.\n',
    )
    ship_date: Date = Field(
        ...,
        description='The date that the shipment was (or will be) shippped.  ShipEngine will take the day of week into consideration. For example, if the carrier does not operate on Sundays, then a package that would have shipped on Sunday will ship on Monday instead.\n',
    )
    created_at: DateTime = Field(
        ...,
        description='The date and time that the shipment was created in ShipEngine.',
    )
    shipment_status: ShipmentStatus = Field(
        ..., description='The current status of the shipment'
    )
    ship_to: ShippingAddress = Field(..., description="The recipient's mailing address")
    ship_from: ShippingAddress = Field(
        ...,
        description="The shipment's origin address. If you frequently ship from the same location, consider [creating a warehouse](https://www.shipengine.com/docs/reference/create-warehouse/).  Then you can simply specify the `warehouse_id` rather than the complete address each time.\n",
    )
    return_to: ShippingAddress = Field(
        ...,
        description='The return address for this shipment.  Defaults to the `ship_from` address.\n',
    )
    confirmation: DeliveryConfirmation = Field(
        ...,
        description='The type of delivery confirmation that is required for this shipment.',
    )
    customs: InternationalShipmentOptions = Field(
        ...,
        description='Customs information.  This is usually only needed for international shipments.\n',
    )
    advanced_options: AdvancedShipmentOptions = Field(
        ..., description='Advanced shipment options.  These are entirely optional.'
    )
    insurance_provider: InsuranceProvider = Field(
        ...,
        description='The insurance provider to use for any insured packages in the shipment.\n',
    )
    tags: List[Tag] = Field(
        ...,
        description='Arbitrary tags associated with this shipment.  Tags can be used to categorize shipments, and shipments can be queried by their tags.\n',
        min_length=0,
    )
    packages: List[Package] = Field(
        ...,
        description="The packages in the shipment.\n\n> **Note:** Some carriers only allow one package per shipment.  If you attempt to create a multi-package shipment for a carrier that doesn't allow it, an error will be returned.\n",
        min_length=1,
    )
    total_weight: Weight = Field(
        ..., description='The combined weight of all packages in the shipment'
    )


class CreateLabelFromRateResponseBody(Label):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class CreateLabelFromShipmentResponseBody(Label):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class CreateLabelRequestBody(Label):
    model_config = ConfigDict(
        extra='forbid',
    )
    ship_from_service_point_id: Optional[str] = Field(
        None,
        description="A unique identifier for a carrier drop off point where a merchant plans to deliver packages. This will take precedence over a shipment's ship from address.",
        examples=['614940'],
    )
    ship_to_service_point_id: Optional[str] = Field(
        None,
        description="A unique identifier for a carrier service point where the shipment will be delivered by the carrier. This will take precedence over a shipment's ship to address.",
        examples=['614940'],
    )
    shipment: Shipment = Field(
        ..., description='The shipment information used to generate the label'
    )


class CreateLabelResponseBody(Label):
    model_config = ConfigDict(
        extra='forbid',
    )
    label_id: SeId = Field(
        ...,
        description='A string that uniquely identifies the label. This ID is generated by ShipEngine when the label is created.\n',
    )
    status: LabelStatus
    shipment_id: SeId = Field(
        ...,
        description='The shipment that this label is for.  ShipEngine can create a shipment for you automatically when you [create a label](https://www.shipengine.com/docs/labels/create-a-label/), or you can [create your own shipment](https://www.shipengine.com/docs/shipping/create-a-shipment/) and then [use it to print a label](https://www.shipengine.com/docs/labels/create-from-shipment/)\n',
    )
    ship_date: Date = Field(
        ...,
        description='The date that the package was (or will be) shippped.  ShipEngine will take the day of week into consideration. For example, if the carrier does not operate on Sundays, then a package that would have shipped on Sunday will ship on Monday instead.\n',
    )
    created_at: DateTime = Field(
        ..., description='The date and time that the label was created in ShipEngine.'
    )
    shipment_cost: MonetaryValue = Field(
        ...,
        description='The cost of shipping, delivery confirmation, and other carrier charges.  This amount **does not** include insurance costs.\n',
    )
    insurance_cost: MonetaryValue = Field(
        ...,
        description='The insurance cost for this package.  Add this to the `shipment_cost` field to get the total cost.\n',
    )
    tracking_number: constr(min_length=1) = Field(
        ...,
        description='The tracking number for the package. Tracking number formats vary across carriers.',
        examples=['782758401696'],
    )
    is_international: bool = Field(
        ...,
        description='Indicates whether this is an international shipment.  That is, the originating country and destination country are different.\n',
    )
    batch_id: SeId = Field(
        ...,
        description='If this label was created as part of a [batch](https://www.shipengine.com/docs/labels/bulk/), then this is the unique ID of that batch.\n',
    )
    carrier_id: SeId = Field(
        ...,
        description='The unique ID of the [carrier account](https://www.shipengine.com/docs/carriers/setup/) that was used to create this label\n',
    )
    service_code: ServiceCode = Field(
        ...,
        description='The [carrier service](https://www.shipengine.com/docs/shipping/use-a-carrier-service/) used to ship the package, such as `fedex_ground`, `usps_first_class_mail`, `flat_rate_envelope`, etc.\n',
    )
    voided: bool = Field(
        ...,
        description='Indicates whether the label has been [voided](https://www.shipengine.com/docs/labels/voiding/)\n',
    )
    voided_at: DateTime = Field(
        ...,
        description='The date and time that the label was [voided](https://www.shipengine.com/docs/labels/voiding/), or `null` if the label has not been voided\n',
    )
    label_image_id: ImageId = Field(
        ...,
        description='The label image resource that was used to create a custom label image.',
    )
    label_format: LabelFormat = Field(
        ...,
        description='The file format that you want the label to be in.  We recommend `pdf` format because it is supported by all carriers, whereas some carriers do not support the `png` or `zpl` formats.\n',
    )
    label_layout: LabelLayout = Field(
        ...,
        description='The layout (size) that you want the label to be in.  The `label_format` determines which sizes are allowed.  `4x6` is supported for all label formats, whereas `letter` (8.5" x 11") is only supported for `pdf` format.\n',
    )
    trackable: bool = Field(
        ...,
        description='Indicates whether the shipment is trackable, in which case the `tracking_status` field will reflect the current status and each package will have a `tracking_number`.\n',
    )
    carrier_code: CarrierCode = Field(
        ...,
        description='The [shipping carrier](https://www.shipengine.com/docs/carriers/setup/) who will ship the package, such as `fedex`, `dhl_express`, `stamps_com`, etc.\n',
    )
    tracking_status: TrackingStatus = Field(
        ...,
        description='The current status of the package, such as `in_transit` or `delivered`',
    )
    label_download: LabelDownload
    form_download: Link = Field(
        ...,
        description='The link to download the customs form (a.k.a. commercial invoice) for this shipment, if any.  Forms are in PDF format. This field is null if the shipment does not require a customs form, or if the carrier does not support it.\n',
    )
    insurance_claim: Link = Field(
        ...,
        description='The link to submit an insurance claim for the shipment.  This field is null if the shipment is not insured or if the insurance provider does not support online claim submission.\n',
    )
    packages: List[Package] = Field(
        ...,
        description="The label's package(s).\n\n> **Note:** Some carriers only allow one package per label.  If you attempt to create a multi-package label for a carrier that doesn't allow it, an error will be returned.\n",
    )
    is_return_label: bool = Field(
        ...,
        description='Indicates whether this is a return label.  You may also want to set the `rma_number` so you know what is being returned.\n',
    )
    rma_number: str = Field(
        ...,
        description='An optional Return Merchandise Authorization number.  This field is useful for return labels.  You can set it to any string value.\n',
    )
    charge_event: LabelChargeEvent = Field(..., description='The label charge event.\n')
    package_code: PackageCode = Field(
        ...,
        description='The [package type](https://www.shipengine.com/docs/reference/list-carrier-packages/), such as `thick_envelope`, `small_flat_rate_box`, `large_package`, etc.  The code `package` indicates a custom or unknown package type.\n',
    )
    display_scheme: DisplayScheme = Field(
        ..., description='The display format that the label should be shown in.'
    )


class CreateReturnLabelResponseBody(Label):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class GetLabelByExternalShipmentIdResponseBody(Label):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class GetLabelByIdResponseBody(Label):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )

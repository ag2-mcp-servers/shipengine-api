# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T09:12:22+00:00



import argparse
import json
import os
from datetime import datetime
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from pydantic import conint, constr

from models import (
    AddFundsToCarrierRequestBody,
    AddFundsToCarrierResponseBody,
    AddFundsToInsuranceRequestBody,
    AddFundsToInsuranceResponseBody,
    AddToBatchRequestBody,
    BatchesSortBy,
    BatchStatus,
    CalculateRatesRequestBody,
    CalculateRatesResponseBody,
    CarrierName,
    CarrierNameWithSettings,
    CompareBulkRatesRequestBody,
    CompareBulkRatesResponseBody,
    ConnectCarrierRequestBody,
    ConnectCarrierResponseBody,
    ConnectInsurerRequestBody,
    ConnectInsurerResponseBody,
    CreateBatchRequestBody,
    CreateBatchResponseBody,
    CreateLabelFromRateRequestBody,
    CreateLabelFromRateResponseBody,
    CreateLabelFromShipmentRequestBody,
    CreateLabelFromShipmentResponseBody,
    CreateLabelRequestBody,
    CreateLabelResponseBody,
    CreateManifestRequestBody,
    CreateManifestResponseBody,
    CreatePackageTypeRequestBody,
    CreatePackageTypeResponseBody,
    CreateReturnLabelRequestBody,
    CreateReturnLabelResponseBody,
    CreateShipmentsRequestBody,
    CreateShipmentsResponseBody,
    CreateTagResponseBody,
    CreateWarehouseRequestBody,
    CreateWarehouseResponseBody,
    CreateWebhookRequestBody,
    CreateWebhookResponseBody,
    DeletePickupByIdResponseBody,
    DisconnectInsurerResponseBody,
    DownloadFilePdfResponseBody,
    EmptyResponseBody,
    ErrorResponseBody,
    EstimateRatesRequestBody,
    EstimateRatesResponseBody,
    GetBatchByExternalIdResponseBody,
    GetBatchByIdResponseBody,
    GetCarrierByIdResponseBody,
    GetCarrierOptionsResponseBody,
    GetCarrierSettingsResponseBody,
    GetCarriersResponseBody,
    GetInsuranceBalanceResponseBody,
    GetLabelByExternalShipmentIdResponseBody,
    GetLabelByIdResponseBody,
    GetManifestByIdResponseBody,
    GetPackageTypeByIdResponseBody,
    GetPickupByIdResponseBody,
    GetPickupsResponseBody,
    GetRateByIdResponseBody,
    GetServicePointByIdResponseBody,
    GetServicePointsRequest,
    GetShipmentByExternalIdResponseBody,
    GetShipmentByIdResponseBody,
    GetTrackingLogFromLabelResponseBody,
    GetTrackingLogResponseBody,
    GetWarehouseByIdResponseBody,
    GetWebhookByIdResponseBody,
    LabelDownloadType,
    LabelIds,
    LabelStatus,
    ListBatchErrorsResponseBody,
    ListBatchesResponseBody,
    ListCarrierPackageTypesResponseBody,
    ListCarrierServicesResponseBody,
    ListLabelsResponseBody,
    ListManifestsResponseBody,
    ListPackageTypesResponseBody,
    ListServicePointsResponseBody,
    ListShipmentRatesResponseBody,
    ListShipmentsResponseBody,
    ListTagsResponseBody,
    ListWarehousesResponseBody,
    ListWebhooksResponseBody,
    ParseAddressRequestBody,
    ParseAddressResponseBody,
    ParseShipmentRequestBody,
    ParseShipmentResponseBody,
    PickupResourceId,
    ProcessBatchRequestBody,
    Redirect,
    RemoveFromBatchRequestBody,
    SchedulePickupRequestBody,
    SchedulePickupResponseBody,
    SeId,
    ServiceCode,
    ShipmentsSortBy,
    ShipmentStatus,
    SortBy,
    SortDir,
    TagName,
    TagShipmentResponseBody,
    TokensGetEphemeralTokenResponseBodyYaml,
    UpdateCarrierSettingsRequestBody,
    UpdatePackageTypeRequestBody,
    UpdateShipmentRequestBody,
    UpdateShipmentResponseBody,
    UpdateWarehouseRequestBody,
    UpdateWarehouseSettingsRequestBody,
    UpdateWebhookRequestBody,
    ValidateAddressRequestBody,
    ValidateAddressResponseBody,
    VoidLabelResponseBody,
)

app = MCPProxy(
    contact={
        'email': 'sales@shipengine.com',
        'name': 'ShipEngine Sales & Support',
        'url': 'https://www.shipengine.com/contact/',
        'x-phone': '1-512-856-5379',
    },
    description="ShipEngine's easy-to-use REST API lets you manage all of your shipping needs without worrying about the complexities of different carrier APIs and protocols. We handle all the heavy lifting so you can focus on providing a first-class shipping experience for your customers at the best possible prices.\n\nEach of ShipEngine's features can be used by itself or in conjunction with each other to build powerful shipping functionality into your application or service.\n\n## Getting Started\nIf you're new to REST APIs then be sure to read our [introduction to REST](https://www.shipengine.com/docs/rest/) to understand the basics.  Learn how to [authenticate yourself to ShipEngine](https://www.shipengine.com/docs/auth/), and then use our [sandbox environment](https://www.shipengine.com/docs/sandbox/) to kick the tires and get familiar with our API. If you run into any problems, then be sure to check the [error handling guide](https://www.shipengine.com/docs/errors/) for tips.\n\nHere are some step-by-step **tutorials** to get you started:\n\n  - [Learn how to create your first shipping label](https://www.shipengine.com/docs/labels/create-a-label/)\n  - [Calculate shipping costs and compare rates across carriers](https://www.shipengine.com/docs/rates/)\n  - [Track packages on-demand or in real time](https://www.shipengine.com/docs/tracking/)\n  - [Validate mailing addresses anywhere on Earth](https://www.shipengine.com/docs/addresses/validation/)\n\n\n## Shipping Labels for Every Major Carrier\nShipEngine makes it easy to [create shipping labels for any carrier](https://www.shipengine.com/docs/labels/create-a-label/) and [download them](https://www.shipengine.com/docs/labels/downloading/) in a [variety of file formats](https://www.shipengine.com/docs/labels/formats/). You can even customize labels with your own [messages](https://www.shipengine.com/docs/labels/messages/) and [images](https://www.shipengine.com/docs/labels/branding/).\n\n\n## Real-Time Package Tracking\nWith ShipEngine you can [get the current status of a package](https://www.shipengine.com/docs/tracking/) or [subscribe to real-time tracking updates](https://www.shipengine.com/docs/tracking/webhooks/) via webhooks. You can also create [custimized tracking pages](https://www.shipengine.com/docs/tracking/branded-tracking-page/) with your own branding so your customers will always know where their package is.\n\n\n## Compare Shipping Costs Across Carriers\nMake sure you ship as cost-effectively as possible by [comparing rates across carriers](https://www.shipengine.com/docs/rates/get-shipment-rates/) using the ShipEngine Rates API. Or if you don't know the full shipment details yet, then you can [get rate estimates](https://www.shipengine.com/docs/rates/estimate/) with limited address info.\n\n\n## Worldwide Address Validation\nShipEngine supports [address validation](https://www.shipengine.com/docs/addresses/validation/) for virtually [every country on Earth](https://www.shipengine.com/docs/addresses/validation/countries/), including the United States, Canada, Great Britain, Australia, Germany, France, Norway, Spain, Sweden, Israel, Italy, and over 160 others.\n",
    termsOfService='https://www.shipengine.com/terms-of-service/',
    title='ShipEngine API',
    version='1.1.202303022103',
    servers=[{'url': 'https://api.shipengine.com'}],
)


@app.put(
    '/v1/addresses/recognize',
    description=""" The address-recognition API makes it easy for you to extract address data from unstructured text, including the recipient name, line 1, line 2, city, postal code, and more.

Data often enters your system as unstructured text (for example: emails, SMS messages, support tickets, or other documents). ShipEngine's address-recognition API helps you extract meaningful, structured data from this unstructured text. The parsed address data is returned in the same structure that's used for other ShipEngine APIs, such as address validation, rate quotes, and shipping labels.

> **Note:** Address recognition is currently supported for the United States, Canada, Australia, New Zealand, the United Kingdom, and Ireland.
 """,
    tags=['address_validation'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def parse_address(body: ParseAddressRequestBody):
    """
    Parse an address
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/addresses/validate',
    description=""" Address validation ensures accurate addresses and can lead to reduced shipping costs by preventing address correction surcharges.
ShipEngine cross references multiple databases to validate addresses and identify potential deliverability issues.
 """,
    tags=['address_validation'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def validate_address(body: ValidateAddressRequestBody):
    """
    Validate An Address
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/batches',
    description=""" List Batches associated with your Shipengine account """,
    tags=['batch_processing'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def list_batches(
    status: Optional[BatchStatus] = None,
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=1)] = 25,
    sort_dir: Optional[SortDir] = 'desc',
    batch_number: Optional[str] = None,
    sort_by: Optional[BatchesSortBy] = None,
):
    """
    List Batches
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/batches',
    description=""" Create a Batch """,
    tags=['batch_processing'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def create_batch(body: CreateBatchRequestBody):
    """
    Create A Batch
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/batches/external_batch_id/{external_batch_id}',
    description=""" Get Batch By External ID """,
    tags=['batch_processing'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def get_batch_by_external_id(external_batch_id: str):
    """
    Get Batch By External ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/batches/{batch_id}',
    description=""" Delete Batch By Id """,
    tags=['batch_processing'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def delete_batch(batch_id: SeId):
    """
    Delete Batch By Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/batches/{batch_id}',
    description=""" Get Batch By ID """,
    tags=['batch_processing'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def get_batch_by_id(batch_id: SeId):
    """
    Get Batch By ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/batches/{batch_id}',
    description=""" Update Batch By Id """,
    tags=['batch_processing'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def update_batch(batch_id: SeId):
    """
    Update Batch By Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/batches/{batch_id}/add',
    description=""" Add a Shipment or Rate to a Batch """,
    tags=['batch_processing'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def add_to_batch(batch_id: SeId, body: AddToBatchRequestBody = ...):
    """
    Add to a Batch
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/batches/{batch_id}/errors',
    description=""" Error handling in batches are handled differently than in a single synchronous request.
You must retrieve the status of your batch by [getting a batch](https://www.shipengine.com/docs/reference/get-batch-by-id/) and getting an overview of the statuses or you can list errors directly here below to get detailed information about the errors.
 """,
    tags=['batch_processing'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def list_batch_errors(
    page: Optional[conint(ge=1)] = 1,
    pagesize: Optional[conint(ge=1)] = None,
    batch_id: SeId = ...,
):
    """
    Get Batch Errors
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/batches/{batch_id}/process/labels',
    description=""" Process Batch ID Labels """,
    tags=['batch_processing', 'label_creation_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def process_batch(batch_id: SeId, body: ProcessBatchRequestBody = ...):
    """
    Process Batch ID Labels
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/batches/{batch_id}/remove',
    description=""" Remove a shipment or rate from a batch """,
    tags=['batch_processing'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def remove_from_batch(batch_id: SeId, body: RemoveFromBatchRequestBody = ...):
    """
    Remove From Batch
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/carriers',
    description=""" List all carriers that have been added to this account """,
    tags=['carrier_configuration'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def list_carriers():
    """
    List Carriers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/carriers/{carrier_id}',
    description=""" Retrive carrier info by ID """,
    tags=['carrier_configuration'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def get_carrier_by_id(carrier_id: SeId):
    """
    Get Carrier By ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/carriers/{carrier_id}/add_funds',
    description=""" Add Funds To A Carrier """,
    tags=['insurance_fund_management', 'carrier_configuration'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def add_funds_to_carrier(carrier_id: SeId, body: AddFundsToCarrierRequestBody = ...):
    """
    Add Funds To Carrier
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/carriers/{carrier_id}/options',
    description=""" Get a list of the options available for the carrier """,
    tags=['carrier_configuration'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def get_carrier_options(carrier_id: SeId):
    """
    Get Carrier Options
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/carriers/{carrier_id}/packages',
    description=""" List the package types associated with the carrier """,
    tags=['carrier_configuration', 'custom_package_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def list_carrier_package_types(carrier_id: SeId):
    """
    List Carrier Package Types
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/carriers/{carrier_id}/services',
    description=""" List the services associated with the carrier ID """,
    tags=['carrier_configuration'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def list_carrier_services(carrier_id: SeId):
    """
    List Carrier Services
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/connections/carriers/{carrier_name}',
    description=""" Connect a carrier account """,
    tags=['carrier_configuration'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def connect_carrier(carrier_name: CarrierName, body: ConnectCarrierRequestBody = ...):
    """
    Connect a carrier account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/connections/carriers/{carrier_name}/{carrier_id}',
    description=""" Disconnect a carrier """,
    tags=['carrier_configuration'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def disconnect_carrier(carrier_name: CarrierName, carrier_id: SeId = ...):
    """
    Disconnect a carrier
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/connections/carriers/{carrier_name}/{carrier_id}/settings',
    description=""" Get carrier settings """,
    tags=['carrier_configuration'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def get_carrier_settings(carrier_name: CarrierNameWithSettings, carrier_id: SeId = ...):
    """
    Get carrier settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/connections/carriers/{carrier_name}/{carrier_id}/settings',
    description=""" Update carrier settings """,
    tags=['carrier_configuration'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def update_carrier_settings(
    carrier_name: CarrierNameWithSettings,
    carrier_id: SeId = ...,
    body: UpdateCarrierSettingsRequestBody = ...,
):
    """
    Update carrier settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/connections/insurance/shipsurance',
    description=""" Disconnect a Shipsurance Account """,
    tags=['carrier_configuration'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def disconnect_insurer():
    """
    Disconnect a Shipsurance Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/connections/insurance/shipsurance',
    description=""" Connect a Shipsurance Account """,
    tags=['carrier_configuration'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def connect_insurer(body: ConnectInsurerRequestBody):
    """
    Connect a Shipsurance Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/downloads/{dir}/{subdir}/{filename}',
    description=""" Get File """,
    tags=['warehouse_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def download_file(
    download: Optional[str] = None,
    rotation: Optional[int] = None,
    subdir: str = ...,
    filename: str = ...,
    dir: str = ...,
):
    """
    Download File
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/environment/webhooks',
    description=""" List all webhooks currently enabled for the account. """,
    tags=['webhook_configuration'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def list_webhooks():
    """
    List Webhooks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/environment/webhooks',
    description=""" Create a webook for specific events in the environment. """,
    tags=['webhook_configuration'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def create_webhook(body: CreateWebhookRequestBody):
    """
    Create a Webhook
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/environment/webhooks/{webhook_id}',
    description=""" Delete a webhook """,
    tags=['webhook_configuration'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def delete_webhook(webhook_id: SeId):
    """
    Delete Webhook By ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/environment/webhooks/{webhook_id}',
    description=""" Retrieve individual webhook by an ID """,
    tags=['webhook_configuration'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def get_webhook_by_id(webhook_id: SeId):
    """
    Get Webhook By ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/environment/webhooks/{webhook_id}',
    description=""" Update the webhook url property """,
    tags=['webhook_configuration'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def update_webhook(webhook_id: SeId, body: UpdateWebhookRequestBody = ...):
    """
    Update a Webhook
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/insurance/shipsurance/add_funds',
    description=""" You may need to auto fund your account from time to time. For example, if you don't normally ship items over $100,
and may want to add funds to insurance rather than keeping the account funded.
 """,
    tags=['insurance_fund_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def add_funds_to_insurance(body: AddFundsToInsuranceRequestBody):
    """
    Add Funds To Insurance
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/insurance/shipsurance/balance',
    description=""" Retrieve the balance of your Shipsurance account. """,
    tags=['insurance_fund_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def get_insurance_balance():
    """
    Get Insurance Funds Balance
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/labels',
    description=""" This endpoint returns a list of labels that you've [created](https://www.shipengine.com/docs/labels/create-a-label/). You can optionally filter the results as well as control their sort order and the number of results returned at a time.

By default, all labels are returned, 25 at a time, starting with the most recently created ones.  You can combine multiple filter options to narrow-down the results.  For example, if you only want to get your UPS labels for your east coast warehouse you could query by both `warehouse_id` and `carrier_id`
 """,
    tags=['label_creation_management', 'shipment_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def list_labels(
    label_status: Optional[LabelStatus] = None,
    service_code: Optional[ServiceCode] = None,
    carrier_id: Optional[SeId] = None,
    tracking_number: Optional[constr(min_length=1)] = None,
    batch_id: Optional[SeId] = None,
    rate_id: Optional[SeId] = None,
    shipment_id: Optional[SeId] = None,
    warehouse_id: Optional[SeId] = None,
    created_at_start: Optional[datetime] = None,
    created_at_end: Optional[datetime] = None,
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=1)] = 25,
    sort_dir: Optional[SortDir] = 'desc',
    sort_by: Optional[SortBy] = 'created_at',
):
    """
    List labels
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/labels',
    description=""" Purchase and print a label for shipment """,
    tags=['label_creation_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def create_label(body: CreateLabelRequestBody):
    """
    Purchase Label
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/labels/external_shipment_id/{external_shipment_id}',
    description=""" Find a label by using the external shipment id that was used during label creation
 """,
    tags=['label_creation_management', 'shipment_operations', 'shipment_tracking'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def get_label_by_external_shipment_id(
    label_download_type: Optional[LabelDownloadType] = None,
    external_shipment_id: str = ...,
):
    """
    Get Label By External Shipment ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/labels/rates/{rate_id}',
    description=""" When retrieving rates for shipments using the `/rates` endpoint, the returned information contains a `rate_id` property that can be used
to generate a label without having to refill in the shipment information repeatedly.
 """,
    tags=['label_creation_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def create_label_from_rate(rate_id: SeId, body: CreateLabelFromRateRequestBody = ...):
    """
    Purchase Label with Rate ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/labels/shipment/{shipment_id}',
    description=""" Purchase a label using a shipment ID that has already been created with the desired address and
package info.
 """,
    tags=['label_creation_management', 'shipment_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def create_label_from_shipment(
    shipment_id: SeId, body: CreateLabelFromShipmentRequestBody = ...
):
    """
    Purchase Label with Shipment ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/labels/{label_id}',
    description=""" Retrieve information for individual labels. """,
    tags=['label_creation_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def get_label_by_id(
    label_download_type: Optional[LabelDownloadType] = None, label_id: SeId = ...
):
    """
    Get Label By ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/labels/{label_id}/return',
    description=""" Create a return label """,
    tags=['label_creation_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def create_return_label(label_id: SeId, body: CreateReturnLabelRequestBody = ...):
    """
    Create a return label
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/labels/{label_id}/track',
    description=""" Retrieve the label's tracking information """,
    tags=['label_creation_management', 'shipment_tracking'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def get_tracking_log_from_label(label_id: SeId):
    """
    Get Label Tracking Information
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/labels/{label_id}/void',
    description=""" Void a label by ID to get a refund. """,
    tags=['label_creation_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def void_label(label_id: SeId):
    """
    Void a Label By ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/manifests',
    description=""" Similar to querying shipments, we allow you to query manifests since there will likely be a large number over a long period of time. """,
    tags=['manifest_operations', 'warehouse_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def list_manifests(
    warehouse_id: Optional[SeId] = None,
    ship_date_start: Optional[datetime] = None,
    ship_date_end: Optional[datetime] = None,
    created_at_start: Optional[datetime] = None,
    created_at_end: Optional[datetime] = None,
    carrier_id: Optional[SeId] = None,
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=1)] = 25,
    label_ids: Optional[LabelIds] = None,
):
    """
    List Manifests
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/manifests',
    description=""" Each ShipEngine manifest is created for a specific warehouse, so you'll need to provide the warehouse_id
rather than the ship_from address. You can create a warehouse for each location that you want to create manifests for.
 """,
    tags=['manifest_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def create_manifest(body: CreateManifestRequestBody):
    """
    Create Manifest
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/manifests/requests/{manifest_request_id}',
    description=""" Get Manifest Request By Id """,
    tags=['manifest_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def get_manifest_request_by_id(manifest_request_id: SeId):
    """
    Get Manifest Request By Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/manifests/{manifest_id}',
    description=""" Get Manifest By Id """,
    tags=['manifest_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def get_manifest_by_id(manifest_id: SeId):
    """
    Get Manifest By Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/packages',
    description=""" List the custom package types associated with the account """,
    tags=['custom_package_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def list_package_types():
    """
    List Custom Package Types
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/packages',
    description=""" Create a custom package type to better assist in getting accurate rate estimates """,
    tags=['custom_package_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def create_package_type(body: CreatePackageTypeRequestBody):
    """
    Create Custom Package Type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/packages/{package_id}',
    description=""" Delete a custom package using the ID """,
    tags=['custom_package_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def delete_package_type(package_id: SeId):
    """
    Delete A Custom Package By ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/packages/{package_id}',
    description=""" Get Custom Package Type by ID """,
    tags=['custom_package_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def get_package_type_by_id(package_id: SeId):
    """
    Get Custom Package Type By ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/packages/{package_id}',
    description=""" Update the custom package type object by ID """,
    tags=['custom_package_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def update_package_type(package_id: SeId, body: UpdatePackageTypeRequestBody = ...):
    """
    Update Custom Package Type By ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/pickups',
    description=""" List all pickups that have been scheduled for this carrier """,
    tags=['pickup_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def list_scheduled_pickups(
    carrier_id: Optional[SeId] = None,
    warehouse_id: Optional[SeId] = None,
    created_at_start: Optional[datetime] = None,
    created_at_end: Optional[datetime] = None,
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=1)] = 25,
):
    """
    List Scheduled Pickups
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/pickups',
    description=""" Schedule a package pickup with a carrier """,
    tags=['pickup_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def schedule_pickup(body: SchedulePickupRequestBody):
    """
    Schedule a Pickup
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/pickups/{pickup_id}',
    description=""" Delete a previously-scheduled pickup by ID """,
    tags=['pickup_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def delete_scheduled_pickup(pickup_id: PickupResourceId):
    """
    Delete a Scheduled Pickup
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/pickups/{pickup_id}',
    description=""" Get Pickup By ID """,
    tags=['pickup_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def get_pickup_by_id(pickup_id: PickupResourceId):
    """
    Get Pickup By ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/rates',
    description=""" It's not uncommon that you want to give your customer the choice between whether they want to ship the fastest, cheapest, or the most trusted route. Most companies don't solely ship things using a single shipping option;
so we provide functionality to show you all your options!
 """,
    tags=['shipping_rate_calculation'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def calculate_rates(body: CalculateRatesRequestBody):
    """
    Get Shipping Rates
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/rates/bulk',
    description=""" Get Bulk Shipment Rates """,
    tags=['shipping_rate_calculation'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def compare_bulk_rates(body: CompareBulkRatesRequestBody):
    """
    Get Bulk Rates
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/rates/estimate',
    description=""" Get Rate Estimates """,
    tags=['shipping_rate_calculation'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def estimate_rates(body: EstimateRatesRequestBody):
    """
    Estimate Rates
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/rates/{rate_id}',
    description=""" Retrieve a previously queried rate by its ID """,
    tags=['shipping_rate_calculation'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def get_rate_by_id(rate_id: SeId):
    """
    Get Rate By ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/service_points/list',
    description=""" List carrier service points by location """,
    tags=['service_point_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def service_points_list(body: GetServicePointsRequest):
    """
    List Service Points
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/service_points/{carrier_code}/{country_code}/{service_point_id}',
    description=""" Returns a carrier service point by using the service_point_id """,
    tags=['service_point_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def service_points_get_by_id(
    carrier_code: constr(min_length=1),
    country_code: constr(min_length=2, max_length=2) = ...,
    service_point_id: str = ...,
):
    """
    Get Service Point By ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/shipments',
    description=""" Get list of Shipments """,
    tags=['shipment_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def list_shipments(
    shipment_status: Optional[ShipmentStatus] = None,
    batch_id: Optional[SeId] = None,
    tag: Optional[constr(min_length=1)] = None,
    created_at_start: Optional[datetime] = None,
    created_at_end: Optional[datetime] = None,
    modified_at_start: Optional[datetime] = None,
    modified_at_end: Optional[datetime] = None,
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=1)] = 25,
    sales_order_id: Optional[str] = None,
    sort_dir: Optional[SortDir] = 'desc',
    sort_by: Optional[ShipmentsSortBy] = None,
):
    """
    List Shipments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/shipments',
    description=""" Create one or multiple shipments. """,
    tags=['shipment_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def create_shipments(body: CreateShipmentsRequestBody):
    """
    Create Shipments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/shipments/external_shipment_id/{external_shipment_id}',
    description=""" Query Shipments created using your own custom ID convention using this endpint """,
    tags=['shipment_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def get_shipment_by_external_id(external_shipment_id: str):
    """
    Get Shipment By External ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/shipments/recognize',
    description=""" The shipment-recognition API makes it easy for you to extract shipping data from unstructured text, including people's names, addresses, package weights and dimensions, insurance and delivery requirements, and more.

Data often enters your system as unstructured text (for example: emails, SMS messages, support tickets, or other documents). ShipEngine's shipment-recognition API helps you extract meaningful, structured data from this unstructured text. The parsed shipment data is returned in the same structure that's used for other ShipEngine APIs, so you can easily use the parsed data to create a shipping label.

> **Note:** Shipment recognition is currently supported for the United States, Canada, Australia, New Zealand, the United Kingdom, and Ireland.
 """,
    tags=['shipment_operations', 'address_validation'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def parse_shipment(body: ParseShipmentRequestBody):
    """
    Parse shipping info
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/shipments/{shipment_id}',
    description=""" Get an individual shipment based on its ID """,
    tags=['shipment_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def get_shipment_by_id(shipment_id: SeId):
    """
    Get Shipment By ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/shipments/{shipment_id}',
    description=""" Update a shipment object based on its ID """,
    tags=['shipment_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def update_shipment(shipment_id: SeId, body: UpdateShipmentRequestBody = ...):
    """
    Update Shipment By ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/shipments/{shipment_id}/cancel',
    description=""" Mark a shipment cancelled, if it is no longer needed or being used by your organized. Any label associated with the shipment needs to be voided first
An example use case would be if a batch label creation job is going to run at a set time and only queries `pending` shipments. Marking a shipment as cancelled
would remove it from this process
 """,
    tags=['shipment_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def cancel_shipments(shipment_id: SeId):
    """
    Cancel a Shipment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/shipments/{shipment_id}/rates',
    description=""" Get Rates for the shipment information associated with the shipment ID """,
    tags=['shipping_rate_calculation', 'shipment_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def list_shipment_rates(
    created_at_start: Optional[datetime] = None, shipment_id: SeId = ...
):
    """
    Get Shipment Rates
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/shipments/{shipment_id}/tags/{tag_name}',
    description=""" Remove an existing tag from the Shipment object """,
    tags=['shipment_operations', 'shipment_tag_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def untag_shipment(shipment_id: SeId, tag_name: TagName = ...):
    """
    Remove Tag from Shipment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/shipments/{shipment_id}/tags/{tag_name}',
    description=""" Add a tag to the shipment object """,
    tags=['shipment_tag_management', 'shipment_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def tag_shipment(shipment_id: SeId, tag_name: TagName = ...):
    """
    Add Tag to Shipment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/tags',
    description=""" Get a list of all tags associated with an account. """,
    tags=['shipment_tag_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def list_tags():
    """
    Get Tags
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/tags/{tag_name}',
    description=""" Delete a tag that is no longer needed """,
    tags=['shipment_tag_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def delete_tag(tag_name: TagName):
    """
    Delete Tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/tags/{tag_name}',
    description=""" Create a new Tag for customizing how you track your shipments """,
    tags=['shipment_tag_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def create_tag(tag_name: TagName):
    """
    Create a New Tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/tags/{tag_name}/{new_tag_name}',
    description=""" Change a tag name while still keeping the relevant shipments attached to it """,
    tags=['shipment_tag_management'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def rename_tag(tag_name: TagName, new_tag_name: TagName = ...):
    """
    Update Tag Name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/tokens/ephemeral',
    description=""" This endpoint returns a token that can be passed to an application for authorized access.  The lifetime of this token is 10 seconds. """,
    tags=['shipping_rate_calculation'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def tokens_get_ephemeral_token(redirect: Optional[Redirect] = None):
    """
    Get Ephemeral Token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/tracking',
    description=""" Retrieve package tracking information """,
    tags=['shipment_tracking', 'carrier_configuration'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def get_tracking_log(
    carrier_code: Optional[constr(min_length=1)] = None,
    tracking_number: Optional[constr(min_length=1)] = None,
):
    """
    Get Tracking Information
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/tracking/start',
    description=""" Allows you to subscribe to tracking updates for a package. You specify the carrier_code and tracking_number of the package,
and receive notifications via webhooks whenever the shipping status changes.
 """,
    tags=['shipment_tracking', 'carrier_configuration'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def start_tracking(
    carrier_code: Optional[constr(min_length=1)] = None,
    tracking_number: Optional[constr(min_length=1)] = None,
):
    """
    Start Tracking a Package
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/tracking/stop',
    description=""" Unsubscribe from tracking updates for a package. """,
    tags=['shipment_tracking'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def stop_tracking(
    carrier_code: Optional[constr(min_length=1)] = None,
    tracking_number: Optional[constr(min_length=1)] = None,
):
    """
    Stop Tracking a Package
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/warehouses',
    description=""" Retrieve a list of warehouses associated with this account. """,
    tags=['warehouse_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def list_warehouses():
    """
    List Warehouses
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/warehouses',
    description=""" Create a warehouse location that you can use to create shipping items by simply passing in the generated warehouse id.
If the return address is not supplied in the request body then it is assumed that the origin address is the return address as well
 """,
    tags=['warehouse_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def create_warehouse(body: CreateWarehouseRequestBody):
    """
    Create Warehouse
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/warehouses/{warehouse_id}',
    description=""" Delete a warehouse by ID """,
    tags=['warehouse_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def delete_warehouse(warehouse_id: SeId):
    """
    Delete Warehouse By ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/warehouses/{warehouse_id}',
    description=""" Retrieve warehouse data based on the warehouse ID """,
    tags=['warehouse_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def get_warehouse_by_id(warehouse_id: SeId):
    """
    Get Warehouse By Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/warehouses/{warehouse_id}',
    description=""" Update Warehouse object information """,
    tags=['warehouse_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def update_warehouse(warehouse_id: SeId, body: UpdateWarehouseRequestBody = ...):
    """
    Update Warehouse By Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/warehouses/{warehouse_id}/settings',
    description=""" Update Warehouse settings object information """,
    tags=['warehouse_operations'],
    security=[
        APIKeyHeader(name="API-Key"),
    ],
)
def update_warehouse_settings(
    warehouse_id: SeId, body: UpdateWarehouseSettingsRequestBody = ...
):
    """
    Update Warehouse Settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
